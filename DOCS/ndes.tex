\documentclass{article}

\usepackage[latin1]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{srcltx}
\usepackage{listings}
\usepackage[pdftex]{thumbpdf}
\usepackage[pdftex,colorlinks]{hyperref}

\title{Mes notes sur mon ``simulateur réseau''}

\author{Emmanuel Chaput}


\begin{document}
\maketitle

\tableofcontents

%========================================================================
%
%========================================================================
\section{Tutoriel}

%------------------------------------------------------------------------
\subsection{Introduction}

   Félicitations ! Tu t'apprètes à entrer dans le monde fabuleux de
{\sc ndes}, \ldots

   Il s'agit en gros d'une sorte de librairie astucieusement
agrémentée de nombreux bugs dont le but et de t'aider (ou pas) à faire
ton propre simulateur réseau ! Si tu es moi, tout ça est à peu près
vrai ; pour les autres, il y a mieux ailleurs.

   L'implantation d'un simulateur passera donc par l'écriture d'un
programme C utilisant cette librairie.

%------------------------------------------------------------------------
\subsection{Installation}

\begin{verbatim}
 $ git clone https://github.com/Manu-31/ndes.git
 $ cd ndes
 $ make
 $ make install
\end{verbatim}

   Pas de panique, ça n'installe rien pour le moment !

%------------------------------------------------------------------------
\subsection{Ma première simulation : chouette, une file M/M/1 !}

   Le fichier source (et son Makefile, parce qu'on ne se moque pas du
client) se trouve dans le répertoire {\tt example/tutorial-1}.

   Dans {\sc ndes}, le système va être modélisé par une source, suivie
d'une file d'attente, en aval de laquelle se trouve un serveur suivi
par un puits. Je te laisse faire un dessin et je publierai ici le plus
joli !

%........................................................................
\subsubsection{Création du simulateur}

   Avant toute manipulation, on crée le simulateur de la façon suivante

\begin{verbatim}
#include <motsim.h>

...

   /* Creation du simulateur */
   motSim_create();
\end{verbatim}

%........................................................................
\subsubsection{Création du puits}

   Un puits sera un objet qui reçoit sans rechigner des messages et
qui les détruit instantanément. On le crée très simplement de la façon
suivante

\begin{verbatim}
#include <pdu-sink.h>

...

   struct PDUSink_t       * sink; // Déclaration d'un puits

   ...

   /* Crétion du puits */
   sink = PDUSink_create();
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Création du serveur}

   Dans la mesure où on ne souhaite rien faire de bien intelligent
avec notre serveur, nous allons utiliser un serveur générique, offert
par la maison, qui ne recule devant aucun sacrifice !

   Il s'utilise comme ça 

\begin{verbatim}
#include <srv-gen.h>

...

   struct srvGen_t        * serveur; // Déclaration d'un serveur générique

...

   /* Création du serveur */
   serveur = srvGen_create(sink, (processPDU_t)PDUSink_processPDU);
\end{verbatim}

   La création du serveur est un peu plus compliquée que celle du
puits. La raison est que le serveur doit savoir à qui envoyer les
clients (des {\sc pdu}s pour {\sc ndes}) après les avoir servis. Il
faut donc lui dire quelle fonction leur appliquer (ici {\tt
  PDUSink\_processPDU} un fonction spécifiques aux puits) et à quelle
entité cette fonction s'applique (notre unique puits, ici). Pour
connaître   la fonction, il faut la chercher dans la description de
l'entité cible. Dans notre exemple, la fonction {\tt
  PDUSink\_processPDU} est décrite dans la section dédiée aux puits.

   Plus de précisions sur cette histoire de fonctions dans la section
\ref{section:architecture} de description de l'architecture générale.

   Comme nous voulons une file M/M/1, nous devons dire à notre serveur
que son temps de traitement est exponentiel de paramètre {\tt mu}. Et
zou :

\begin{verbatim}
   float   mu = 10.0; // Paramètre du serveur

   ...

   /* Paramétrage du serveur */
   srvGen_setServiceTime(serveur, serviceTimeExp, mu);
\end{verbatim}

   Les serveurs génériques sont décrits plus précisément dans la
section \ref{section:srv_gen}.

%........................................................................
%
%........................................................................
\subsubsection{Création de la file}

   Une file permet de stocker des {\sc pdu} en transit. On la
construit ainsi

\begin{verbatim}
   struct filePDU_t       * filePDU; // Déclaration de notre file

    ...

   /* Création de la file */
   filePDU = filePDU_create(serveur, (processPDU_t)srvGen_processPDU);
\end{verbatim}

   Sans autre forme de procès, les files ne sont pas bornées. Elles
sont décrites plus précisément dans la section \ref{section:file}. Les
deux paramètres de la fonction de création ont le même rôle que ceux
de la fonction de création du serveur.

%........................................................................
%
%........................................................................
\subsubsection{Création de la source}

   Nous voilà à la source ! Nous allons utiliser un objet de {\sc
ndes} dont le rôle est de produire des {\sc pdu}s. Mais avant cela,
nous devons créer un autre objet qui lui indiquera les dates
auxquelles les produire : il s'agit d'un ``générateur de date'',
original, non ? Les générateurs de dates sont décrits dans la section \ref{section:date_generator}.

   On veut une source poisonnienne, donc un générateur exponentiel :

\begin{verbatim}
#include <date-generator.h>

...

   struct dateGenerator_t * dateGenExp; // Un générateur de dates
   float   lambda = 5.0 ; // Intensité du processus d'arrivée

   ...

   /* Création d'un générateur de date */
   dateGenExp = dateGenerator_createExp(lambda);
\end{verbatim}

   Et maintenant nous pouvons donc créer notre source :

\begin{verbatim}
#include <pdu-source.h>

...

   struct PDUSource_t     * sourcePDU;  // Une source

   ...

   sourcePDU = PDUSource_create(dateGenExp, 
				filePDU,
				(processPDU_t)filePDU_processPDU);
\end{verbatim}

   Le premier paramètre est donc l'objet qui lui permet de déterminer
les dates d'envoi. Les deux suivants sont similaires à ceux passés
lors de la cration de la file et du serveur.
   
%........................................................................
%
%........................................................................
\subsubsection{Mise en place de sondes}

   Oui, je sais, le titre fait un peu peur, mais ça va bien se
passer. Lorsqu'on veut lancer un simulateur, on espère en général
obtenir des résulats. Dans {\sc ndes}, ceux-ci seront collectés par un
outil spécifique, la sonde.

   Les différents types de sonde sont décrits dans la section
\ref{section:sondes}. Nous utiliserons ici uniquement des sondes
exhaustives. Pour chaque objet décrit, la liste des sondes
disponibles est fournie. 

   Nous les déclarons et initialisons comme ça :

\begin{verbatim}
#include <probe.h>

...

   struct probe_t         * sejProbe, * iaProbe, * srvProbe; // Les sondes

...

   /* Une sonde sur les interarrivées */
   iaProbe = probe_createExhaustive();
   dateGenerator_setInterArrivalProbe(dateGenExp, iaProbe);

   /* Une sonde sur les temps de séjour */
   sejProbe = probe_createExhaustive();
   filePDU_addSejournProbe(filePDU, sejProbe);

   /* Une sonde sur les temps de service */
   srvProbe = probe_createExhaustive();
   srvGen_setServiceProbe(serveur, srvProbe);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Lancement de la simulation}

   Ça y est, nous y sommes enfin, voici comment démarrer la
simulation. Nous devons activer les entités voulue au moment
voulu. Ici, il n'y a que l'unique source à activer, et nous souhaitons
le faire dès le début de la simulation :

\begin{verbatim}
   /* On active la source */
   PDUSource_start(sourcePDU);
\end{verbatim}

   Nous lançons maintenant la simulation. Nous allons la faire durer
100 secondes :

\begin{verbatim}
   /* C'est parti pour 100 000 millisecondes de temps simulé */
   motSim_runUntil(100000.0);
\end{verbatim}

   Nous pouvons ensuite afficher quelques paramètres internes du
simulateur :

\begin{verbatim}
   motSim_printStatus();
\end{verbatim}

   Et voilà !

%........................................................................
%
%........................................................................
\subsubsection{Affichage des résultats}

   Maintenant que notre simulation est terminée, on a certainement 
envie d'en voir le résultat. On utilisera pour cela des fonctions
founies par les sondes, par exemple :

\begin{verbatim}
   /* Affichage de quelques résultats scalaires */
   printf("%d paquets restant dans  la file\n",
	  filePDU_length(filePDU));
   printf("Temps moyen de sejour dans la file = %f\n",
	  probe_mean(sejProbe));
   printf("Interarive moyenne     = %f (1/lambda = %f)\n",
	  probe_mean(iaProbe), 1.0/lambda);
   printf("Temps de service moyen = %f (1/mu     = %f)\n",
	  probe_mean(srvProbe), 1.0/mu);
\end{verbatim}

   Génial, non ? Non ! Mais la suite est plus rigolote, \ldots

%........................................................................
%
%........................................................................
\subsubsection{Tracé de courbes}

   Pour obtenir des résultats plus riches, nous allons utiliser
(depuis le simulateur) un affichage {\em gnuplot}. Nous avons ici au
moins deux courbes intéressantes à tracer, donc nous allons écrire une
 fonction pour cela :

\begin{verbatim}

/*
 * Affichage (via gnuplot) de la probre pr
 * elle sera affichée comme un graphbar de nbBar barres
 * avec le nom name
 */
void tracer(struct probe_t * pr, char * name, int nbBar)
{
   struct probe_t   * gb;
   struct gnuplot_t * gp;

   /* On crée une sonde de type GraphBar */
   gb = probe_createGraphBar(probe_min(pr), probe_max(pr), nbBar);

   /* On convertit la sonde passée en paramètre en GraphBar */
   probe_exhaustiveToGraphBar(pr, gb);

   /* On la baptise */
   probe_setName(gb, name);

   /* On initialise une section gnuplot */
   gp = gnuplot_create();

   /* On recadre les choses */
   gnuplot_setXRange(gp, probe_min(gb), probe_max(gb)/2.0);

   /* On affiche */
   gnuplot_displayProbe(gp, WITH_BOXES, gb);
}
\end{verbatim}

   L'utilisation de {\em gnuplot} est décrite dans la section
\ref{section:gnuplot}.

   Attention à ne pas oublier de mettre une petite pause à la fin de
notre programme principal, sinon il s'arrète et il tue ses processus
fils, et donc l'affichage disparait.

%........................................................................
%
%........................................................................
\subsubsection{Utilisation de notre premier simulateur}

   Il ne nous reste plus qu'à compiler notre programme et à le
lancer. Le répertoire {\tt examples/tutorial-1} contient également un
makefile, donc :

\begin{verbatim}
 $ cd examples/tutorial-1
 $ make
 $ ./mm1
\end{verbatim}

%========================================================================
%
%========================================================================
\section{L'architecture générale}
\label{section:architecture}

%========================================================================
%
%========================================================================
\section{Le moteur de simulation}
\label{section:motsim}

%========================================================================
%
%========================================================================
\section{Les sondes}
\label{section:sondes}

   Les sondes sont implantées dans le modules {\tt probe}. Les sondes
permettent d'enregistrer des mesures de paramètres scalaires. Ce sont
elles qui permettront ensuite d'analyser le résultat de la simulation,
d'évaluer les performances du système, de tracer des courbes, \ldots

   Chaque échantillon d'une mesure prélevé par une sonde est daté. Il
est égalament possible de n'enregistrer que la date d'un événement,
sans aucune mesure associée.

   Les sondes peuvent être placées en divers points des outils de
simulation via des fonctions de la forme
\lstinline!<type>_add<point>Probe(...)!. Plusieurs sondes peuvent être
ainsi ``chaînées'' sur un même point de mesure. En revanche, la même
sonde {\bf ne peut pas} être chaînée plusieurs fois.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les méthodes de base}
\subsubsection{L'échantillonage}

   La méthode suivante permet d'échantilloner une valeur dans une
sonde 

\begin{verbatim}
/*
 * Echantillonage d'une valeur
 */
void probe_sample(struct probe_t * probe, double value);
\end{verbatim}

   Il est également possible d'échantilloner une date, sans valeur
associée, de la façon suivante 

\begin{verbatim}
/*
 * Echantillonage de la date d'occurence d'un evenement
 */
void probe_sampleEvent(struct probe_t * probe);
\end{verbatim}

\subsubsection{Consultation d'un échantillon}

\subsubsection{La moyenne}

\subsubsection{Les valeurs extrèmes}


\subsubsection{La sauvegarde}

   Une sonde peut être dumpée dans un fichier ouvert grâce à la
fonction

{\tt void probe\_graphBarDumpFd(struct probe\_t * probe, int fd, int
format);}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsubsection{La mesure du débit}

   Les valeurs échantillonées pourront souvent être des tailles de
messages, émis ou reçus. Dans ce cas, il peut être intéressant
d'utiliser la fonction suivante qui fournit une mesure du ``débit
instantané''.

\begin{verbatim}
double probe_throughput(struct probe_t * p);
\end{verbatim}

   Bien sûr, le mode d'estimation de cette valeur est dépendant de la
nature de la sonde.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les différents types}

\subsubsection{Les ``méta-sondes''}

   À chaque échantillon, certaines sondes mettent à jours des
informations que l'on peut souhaiter conserver (par exemple la moyenne
mobile) afin de tracer leur évolution dans le temps.

   Pour cela, une sonde périodique \lstinline!P! peut être placée sur
une sonde observée \lstinline!O!. La sonde \lstinline!P! permettra
ainsi d'observer une propriété de la sonde\lstinline!O! sur la base
d'un échantillonage à une fréquence caractérisant la sonde
\lstinline!P!. 

   Cette technique permet également de collecter dans une sonde unique
\lstinline!G! des échantillons prélevés dans plusieurs sondes
différentes \lstinline!S1!, \lstinline!S2!, ldots Pour cela,
\lstinline!G! sera ajoutée comme sonde sur les échantillons de
\lstinline!S1!, \lstinline!S2!, ldots 

\subsubsection{La sonde exhaustive}

\subsubsection{L'histogramme}

\subsubsection{La fenêtre glissante}

   Ces sondes conservent tous les échantillons sur une fenêtre
glissante dont la taille est fournie en paramêtre du constructeur :

\begin{verbatim}
struct probe_t * probe_slidingWindowCreate(int windowLength);
\end{verbatim}

\subsubsection{La sonde périodique}

   Le but d'une sonde périodique est de prélever un échantillon toutes
les $\tau$ unitées de temps. On se fonde pour cela sur l'idée que la
valeur mesurée n'est modifier qu'au cours du traitement d'un
événement.


\subsubsection{La moyenne mobile}

   Une moyenne du type \lstinline!EMAProbeType! conserve à tout moment
une moyenne mobile calculée à chaque nouvel échantillon $e$ de la façon
suivante $m <- \alpha . m + (1 - \alpha).e$.

\subsubsection{La moyenne par tranches temporelles}

   Cette sonde conserve une moyenne pour chaque tranche temporelle de
durée {\tt t}, passée en paramètre du constructeur (les fenêtres
temporelles sont sautantes donc disjointes):

\begin{verbatim}
struct probe_t * probe_createTimeAverage(double t);
\end{verbatim}


%========================================================================
%
%========================================================================
\section{Le serveur générique}
\label{section:srv_gen}

   Le serveur générique permet de modéliser à moindre frais un
serveur. Il est définit dans le fichier {\tt srv-gen.h}.

%========================================================================
%
%========================================================================
\section{Le puits}
\label{section:puits}

%========================================================================
%
%========================================================================
\section{Les files}
\label{section:file}

   C'est l'outil de base pour stocker des objets selon une stratégie
{\sc fifo}. Elles sont définies dans le fichier {\tt file\_pdu.h}.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Création}

   Une file est créée de la façon suivante 

\begin{verbatim}
struct filePDU_t * filePDU_create(void * destination,
			    processPDU_t destProcessPDU);
\end{verbatim}

   Le paramètre \lstinline!destination! est un pointeur sur l'objet
vers lequel sont transmis les objets présents dans la file. Dés qu'un
objet est inséré dans la file, si la destination est disponible, il
lui est envoyé.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Gestion de la taille}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les sondes}

   Les files sont dotées des sondes suivantes

\begin{description}
   \item[{\tt InsertSize}] pour mesurer la taille des paquets insérés
     dans la file. A chaque insertion d'une {\sc pdu}, la taille de
     cette dernière est échantillonée avec la date d'insertion.
   \item[{\tt ExtractSize}] pour mesurer la taille des paquets extraits
     de la file. A chaque extraction d'une {\sc pdu}, la taille de
     cette dernière est échantillonée avec la date d'extraction.
   \item[{\tt Sejourn}]
\end{description}


%========================================================================
%
%========================================================================
\section{L'affichage par GnuPlot}
\label{section:gnuplot}

%========================================================================
%
%========================================================================
\section{Notion de simulation et de campagne}

   Une simulation est une instance unique d'exécution d'une séquence
d'événements suite à l'initialisation du modèle. Une campagne est une
suite de simulations sur un même modèle avec une ré-initialisation des
variables entre deus simulations.

   Les sondes liées à la simulation sont ré-initialisées à la fin de
la simulation. Des sondes peuvent être liées à la campagne ; elles ne
seront réinitialisées qu'à la fin de cette dernière et peuvent
permettre ainsi à établir des valeurs inter-simulation, par exemple
des intervalles de confiance.


\section{Des exemples}

\subsection{Utilisation des sondes}

\subsubsection{Mesurer un débit}

   Considérons le cas simple d'une source, dont nous voulons mesurer
le débit de sortie. Pour cela, nous allons insérer une sonde sur la
taille des paquets transmis grâce à la méthode {\tt
  PDUSource\_setPDUGenerationSizeProbe}.

   Le type de sonde dépendra de la mesure souhaitée.

\paragraph{Débit moyen}

   Supposons que nous voulons simplement connaître le débit moyen sur
toute la transmission, alors une sonde mesurant la moyenne sera parfaitement
suffisante :

\paragraph{Débit ``instantanté''}

\section{Vrac}

   Début de doc

   o Modèle de transmission des PDU

   - Tout module susceptible de produire ou transférer des PDU doit
fournir une fonction de la forme

   {\tt struct PDU\_t * getPDU(void * source);}

   Le paramètre est un pointeur vers des "données privées" permettant
d'identifier l'instance du module (typiquement un pointeur direct sur
cette instance).

   Le pointeur retourné est celui d'une PDU qui n'est plus prise en
compte par la source. Elle doit donc absolument être gérée (ou, au
moins, détruite) par l'utilisateur de cette fonction. En cas
d'indisponibilité de PDU, la valeur NULL est retournée.

   Cette fonction et le pointeur associé doivent être fournis à
l'entité destinataire, s'il en existe une !

   Si le nom du module est toto, la fonction sera nommée par exemple
{\tt toto\_getPDU().}

   - Tout module susceptible de recevoir des PDU doit fournir une
fonction de la forme :

{\tt
   void processPDU(void * rec,
                   getPDU\_t getPDU,
                   void * source);
}
   C'est cette fonction qu'invoquera une source pour lui notifier la
disponibilité d'une PDU. Cette fonction aura donc la responsabilité
d'aller récupérer la PDU (grâce la la fonction getPDU et à la source
fournies) et de la traiter. La récupération et le traitement pourront
être remis à plus tard (en cas d'indisponibilité) mais au risque
d'avoir un pointeur NULL retourné par getPDU(). 

   Si le nom du module est {\tt toto}, la fonction sera nommée par exemple
{\tt toto\_processPDU()}.





   Le problème ici est que ce modèle, censé permettre plus simplement
d'avoir plusieurs producteurs vers un même consommateur (grâce à la
fonction getPDU et au pointeur source passés en paramètres plutôt que
stockés comme attributs) rend délicat le "report" de l'invocation du
getPDU. Comment, dans un serveur par exemple, assurer que cette
invocation se fera dans le même traitement que la fin de traitement ?
Cela dit, est-ce vraiment nécessaire ? Pour le moment, cela implique
un événement pour la fin du traitement et un événement pour chaque
getPDU.

  La difficulté est d'assurer un traitement dans le bon ordre de
ces événements qui ont la même date ... J'ai pourtant dans l'idée que
c'est la bonne solution. Plusieurs pistes pour rêgler ce problème des
événements "simultanés" mais devant être traités dans un ordre donné,
sachant que le problème des événements simultanés est complexe :

   . A date égale, les événements sont insérés dans l'ordre de
création et exécutés dans l'ordre d'insertion. Bof, notemment dans la
mesure oû la date est un réel. Avantage : c'est simple !
   . Gérer des chaines d'événements ?

  Bon, en fait, ici, le mieux est peut-être d'abandonner cette
idée. Elle n'est pas logique. Si plusieurs sources signalent des
paquets disponibles, il n'y a aucune raison que ça provoque des
événements simultanés ! Il faut donc stocker le getPDU et le pointeur
associé. Eventuellement dans une liste (ordonnée) pour en permettre
plusieurs. Le traitement n'est pas alors différé à un nouvel événement
mais reporté à la fin du service en cours.


\end{document}
