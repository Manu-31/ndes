\documentclass{article}

\usepackage[latin1]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{srcltx}
\usepackage{listings}
\usepackage[pdftex]{thumbpdf}
\usepackage[pdftex,colorlinks]{hyperref}

\title{Mes notes sur mon ``simulateur réseau''}

\author{Emmanuel Chaput}


\begin{document}
\maketitle

\tableofcontents

%========================================================================
%
%========================================================================
\section{Tutoriel}

%------------------------------------------------------------------------
\subsection{Introduction}

   Félicitations ! Tu t'apprètes à entrer dans le monde fabuleux de
{\sc ndes}, \ldots

   Il s'agit en gros d'une sorte de librairie astucieusement
agrémentée de nombreux bugs dont le but et de t'aider (ou pas) à faire
ton propre simulateur réseau ! Si tu es moi, tout ça est à peu près
vrai ; pour les autres, il y a mieux ailleurs.

   L'implantation d'un simulateur passera donc par l'écriture d'un
programme C utilisant cette librairie.

%------------------------------------------------------------------------
\subsection{Installation}

\begin{verbatim}
 $ git clone https://github.com/Manu-31/ndes.git
 $ cd ndes
 $ make
 $ make install
\end{verbatim}

   Pas de panique, ça n'installe rien pour le moment !

%------------------------------------------------------------------------
\subsection{Ma première simulation : chouette, une file M/M/1 !}

   Le fichier source (et son Makefile, parce qu'on ne se moque pas du
client) se trouve dans le répertoire {\tt example/tutorial-1}.

   Dans {\sc ndes}, le système va être modélisé par une source, suivie
d'une file d'attente, en aval de laquelle se trouve un serveur suivi
par un puits. Je te laisse faire un dessin et je publierai ici le plus
joli !

%........................................................................
\subsubsection{Création du simulateur}

   Avant toute manipulation, on crée le simulateur de la façon suivante

\begin{verbatim}
#include <motsim.h>

...

   /* Creation du simulateur */
   motSim_create();
\end{verbatim}

%........................................................................
\subsubsection{Création du puits}

   Un puits sera un objet qui reçoit sans rechigner des messages et
qui les détruit instantanément. On le crée très simplement de la façon
suivante

\begin{verbatim}
#include <pdu-sink.h>

...

   struct PDUSink_t       * sink; // Déclaration d'un puits

   ...

   /* Crétion du puits */
   sink = PDUSink_create();
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Création du serveur}

   Dans la mesure où on ne souhaite rien faire de bien intelligent
avec notre serveur, nous allons utiliser un serveur générique, offert
par la maison, qui ne recule devant aucun sacrifice !

   Il s'utilise comme ça 

\begin{verbatim}
#include <srv-gen.h>

...

   struct srvGen_t        * serveur; // Déclaration d'un serveur générique

...

   /* Création du serveur */
   serveur = srvGen_create(sink, (processPDU_t)PDUSink_processPDU);
\end{verbatim}

   La création du serveur est un peu plus compliquée que celle du
puits. La raison est que le serveur doit savoir à qui envoyer les
clients (des {\sc pdu}s pour {\sc ndes}) après les avoir servis. Il
faut donc lui dire quelle fonction leur appliquer (ici {\tt
  PDUSink\_processPDU} un fonction spécifiques aux puits) et à quelle
entité cette fonction s'applique (notre unique puits, ici). Pour
connaître   la fonction, il faut la chercher dans la description de
l'entité cible. Dans notre exemple, la fonction {\tt
  PDUSink\_processPDU} est décrite dans la section dédiée aux puits.

   Plus de précisions sur cette histoire de fonctions dans la section
\ref{section:architecture} de description de l'architecture générale.

   Comme nous voulons une file M/M/1, nous devons dire à notre serveur
que son temps de traitement est exponentiel de paramètre {\tt mu}. Et
zou :

\begin{verbatim}
   float   mu = 10.0; // Paramètre du serveur

   ...

   /* Paramétrage du serveur */
   srvGen_setServiceTime(serveur, serviceTimeExp, mu);
\end{verbatim}

   Les serveurs génériques sont décrits plus précisément dans la
section \ref{section:srv_gen}.

%........................................................................
%
%........................................................................
\subsubsection{Création de la file}

   Une file permet de stocker des {\sc pdu} en transit. On la
construit ainsi

\begin{verbatim}
   struct filePDU_t       * filePDU; // Déclaration de notre file

    ...

   /* Création de la file */
   filePDU = filePDU_create(serveur, (processPDU_t)srvGen_processPDU);
\end{verbatim}

   Sans autre forme de procès, les files ne sont pas bornées. Elles
sont décrites plus précisément dans la section \ref{section:file}. Les
deux paramètres de la fonction de création ont le même rôle que ceux
de la fonction de création du serveur.

%........................................................................
%
%........................................................................
\subsubsection{Création de la source}

   Nous voilà à la source ! Nous allons utiliser un objet de {\sc
ndes} dont le rôle est de produire des {\sc pdu}s. Mais avant cela,
nous devons créer un autre objet qui lui indiquera les dates
auxquelles les produire : il s'agit d'un ``générateur de date'',
original, non ? Les générateurs de dates sont décrits dans la section \ref{section:date_generator}.

   On veut une source poisonnienne, donc un générateur exponentiel :

\begin{verbatim}
#include <date-generator.h>

...

   struct dateGenerator_t * dateGenExp; // Un générateur de dates
   float   lambda = 5.0 ; // Intensité du processus d'arrivée

   ...

   /* Création d'un générateur de date */
   dateGenExp = dateGenerator_createExp(lambda);
\end{verbatim}

   Et maintenant nous pouvons donc créer notre source :

\begin{verbatim}
#include <pdu-source.h>

...

   struct PDUSource_t     * sourcePDU;  // Une source

   ...

   sourcePDU = PDUSource_create(dateGenExp, 
				filePDU,
				(processPDU_t)filePDU_processPDU);
\end{verbatim}

   Le premier paramètre est donc l'objet qui lui permet de déterminer
les dates d'envoi. Les deux suivants sont similaires à ceux passés
lors de la cration de la file et du serveur.
   
%........................................................................
%
%........................................................................
\subsubsection{Mise en place de sondes}

   Oui, je sais, le titre fait un peu peur, mais ça va bien se
passer. Lorsqu'on veut lancer un simulateur, on espère en général
obtenir des résulats. Dans {\sc ndes}, ceux-ci seront collectés par un
outil spécifique, la sonde.

   Les différents types de sonde sont décrits dans la section
\ref{section:sondes}. Nous utiliserons ici uniquement des sondes
exhaustives. Pour chaque objet décrit, la liste des sondes
disponibles est fournie. 

   Nous les déclarons et initialisons comme ça :

\begin{verbatim}
#include <probe.h>

...

   struct probe_t         * sejProbe, * iaProbe, * srvProbe; // Les sondes

...

   /* Une sonde sur les interarrivées */
   iaProbe = probe_createExhaustive();
   dateGenerator_setInterArrivalProbe(dateGenExp, iaProbe);

   /* Une sonde sur les temps de séjour */
   sejProbe = probe_createExhaustive();
   filePDU_addSejournProbe(filePDU, sejProbe);

   /* Une sonde sur les temps de service */
   srvProbe = probe_createExhaustive();
   srvGen_setServiceProbe(serveur, srvProbe);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Lancement de la simulation}

   Ça y est, nous y sommes enfin, voici comment démarrer la
simulation. Nous devons activer les entités voulue au moment
voulu. Ici, il n'y a que l'unique source à activer, et nous souhaitons
le faire dès le début de la simulation :

\begin{verbatim}
   /* On active la source */
   PDUSource_start(sourcePDU);
\end{verbatim}

   Nous lançons maintenant la simulation. Nous allons la faire durer
100 secondes :

\begin{verbatim}
   /* C'est parti pour 100 000 millisecondes de temps simulé */
   motSim_runUntil(100000.0);
\end{verbatim}

   Nous pouvons ensuite afficher quelques paramètres internes du
simulateur :

\begin{verbatim}
   motSim_printStatus();
\end{verbatim}

   Et voilà !

%........................................................................
%
%........................................................................
\subsubsection{Affichage des résultats}

   Maintenant que notre simulation est terminée, on a certainement 
envie d'en voir le résultat. On utilisera pour cela des fonctions
founies par les sondes, par exemple :

\begin{verbatim}
   /* Affichage de quelques résultats scalaires */
   printf("%d paquets restant dans  la file\n",
	  filePDU_length(filePDU));
   printf("Temps moyen de sejour dans la file = %f\n",
	  probe_mean(sejProbe));
   printf("Interarive moyenne     = %f (1/lambda = %f)\n",
	  probe_mean(iaProbe), 1.0/lambda);
   printf("Temps de service moyen = %f (1/mu     = %f)\n",
	  probe_mean(srvProbe), 1.0/mu);
\end{verbatim}

   Génial, non ? Non ! Mais la suite est plus rigolote, \ldots

%........................................................................
%
%........................................................................
\subsubsection{Tracé de courbes}

   Pour obtenir des résultats plus riches, nous allons utiliser
(depuis le simulateur) un affichage {\em gnuplot}. Nous avons ici au
moins deux courbes intéressantes à tracer, donc nous allons écrire une
 fonction pour cela :

\begin{verbatim}

/*
 * Affichage (via gnuplot) de la probre pr
 * elle sera affichée comme un graphbar de nbBar barres
 * avec le nom name
 */
void tracer(struct probe_t * pr, char * name, int nbBar)
{
   struct probe_t   * gb;
   struct gnuplot_t * gp;

   /* On crée une sonde de type GraphBar */
   gb = probe_createGraphBar(probe_min(pr), probe_max(pr), nbBar);

   /* On convertit la sonde passée en paramètre en GraphBar */
   probe_exhaustiveToGraphBar(pr, gb);

   /* On la baptise */
   probe_setName(gb, name);

   /* On initialise une section gnuplot */
   gp = gnuplot_create();

   /* On recadre les choses */
   gnuplot_setXRange(gp, probe_min(gb), probe_max(gb)/2.0);

   /* On affiche */
   gnuplot_displayProbe(gp, WITH_BOXES, gb);
}
\end{verbatim}

   L'utilisation de {\em gnuplot} est décrite dans la section
\ref{section:gnuplot}.

   Attention à ne pas oublier de mettre une petite pause à la fin de
notre programme principal, sinon il s'arrète et il tue ses processus
fils, et donc l'affichage {\rm gnuplot} disparaît.

%........................................................................
%
%........................................................................
\subsubsection{Utilisation de notre premier simulateur}

   Il ne nous reste plus qu'à compiler notre programme et à le
lancer. Le répertoire {\tt examples/tutorial-1} contient également un
makefile que je te laisse observer, mais en gros, il faut aller
chercher les includes et la librairie. En utilisant ce {\tt Makefile},
on a donc :

\begin{verbatim}
 $ cd examples/tutorial-1
 $ make
 $ ./mm1
[MOTSI] Date = 99999.846555
[MOTSI] Events : 998243 created (3 m + 998240 r)/998242 freed
[MOTSI] Simulated events : 998243 in, 998242 out, 1 pr.
[MOTSI] PDU : 998242 created (27 m + 998215 r)/998242 freed
[MOTSI] Total malloc'ed memory : 25169976 bytes
[MOTSI] Realtime duration : 1 sec
0 paquets restant dans  la file
Temps moyen de sejour dans la file = 0.061008
Interarive moyenne     = 0.200352 (1/lambda = 0.200000)
Temps de service moyen = 0.100176 (1/mu     = 0.100000)
*** ^C pour finir ;-)
 $
\end{verbatim}


%------------------------------------------------------------------------
\subsection{Ma deuxiéme simulation : super, encore une file M/M/1 !}

   Le premier exemple est sympa, vas-tu me dire, mais ce serait mieux
si le temps de traitement dépendait de la taille des clients (comme
des paquets dont le temps d'émission dépend de la taille !)

   Et bien soit ! C'est ce que nous allons faire dans ce deuxième
tutoriel. Les fichiers se trouvent dans le répertoire {\tt
example/tutorial-2}.


 

%========================================================================
%
%========================================================================
\section{L'architecture générale}
\label{section:architecture}

   Le but de cette section est de décrire la logique de {\sc
ndes}.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Type de simulation}

   {\sc Ndes} est une librairie de simulation de réseaux par événements
discrets. Non, ce n'est pas original, mais c'est tout de même
vachement important pour la suite. Tout le code de traitement d'un
événement que l'on va écrire sera exécuté en une durée éventuelllement
super longue, mais absolument pas comptabilisé dans le temps
simulé. Et pire ! Pendant le traitement d'un événement, comme le temps
simulé est figé, le système n'évolue pas (sauf au travers du code en
question). C'est du connu, d'accord, mais c'est lourd de conséquences
(musique stressante).

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Schéma général des modèles}

   L'idée fondamentale est que le réseau à simuler peut être
modélisé comme une suite d'entitées chaînées entre elles. Dans la
version la plus simple, strictement linéaire, la première de ces
entités va produire des messages, nommés {\sc pdu}s, qu'elle fera
suivre à l'entité suivante et ainsi de suite jusqu'à la dernière qui
pourra sonserver les messages ou les détruire.

   La file M/M/1 décrite dans le premier tutoriel est un parfait
exemple de ce modèle. Nous connaissons donc déjà quatre types de
noeuds : {\tt sourcePDU}, {\tt filePDU}, {\tt serv\_gen} et {\tt PDUSink}.

   La construction du réseau se fait en partant ``de la fin'' et en
remontant vers la source, comme on peut le voir dans le
tutoriel. Chaque fois que l'on crée une entité, on doit lui passer
comme paramètres des informations sur l'entité en aval. Elle n'a, en
revanche, aucun besoin de connaître la ou les entités amont. Oui, il
peut y en avoir plusieurs.

   Certaines entités peuvent également avoir plusieurs entités aval
(qui seront fournies par une fonction spécifique), mais une {\sc pdu}
donnée n'est passée qu'à une seule d'entre elles.

   La mauvaise nouvelle, c'est que que ce schéma va être à revoir tôt
ou tard ! Il n'est pas génial pour modéliser des choses plus
symétriques (une entité protocolaire qui émet et reçoit), et des
choses sont à revoir comme le terme de {\sc pdu} qui n'est pas du tout
approprié. Ce ne sont pas que des {\sc pdu} qui sont représentées par
cette chose !

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Fonctions d'échange des {\sc pdu}}

   Du fait de l'architecture générale du réseau, pour toute entité susceptible
de produire ou transférer des PDU doit exister une fonction de la forme

\begin{verbatim}
 struct PDU_t * getPDU(void * source);
\end{verbatim}

   Le paramètre est un pointeur vers des "données privées" permettant
d'identifier le noeud (typiquement un pointeur direct sur ce noeud).

   Le pointeur retourné est celui d'une PDU qui n'est plus prise en
compte par la source. Elle doit donc absolument être gérée (ou, au
moins, détruite) par l'utilisateur de cette fonction. En cas
d'indisponibilité de PDU, la valeur {\tt NULL} est retournée.

   Cette fonction et le pointeur associé doivent être fournis à
l'entité destinataire, s'il en existe une !

   Si le nom du module est toto, la fonction sera nommée par exemple
{\tt toto\_getPDU().}\\

   Symétriquement, tout module susceptible de recevoir des PDU doit fournir une
fonction de la forme :


\begin{verbatim}
   void processPDU(void * rec,
                   getPDU\_t getPDU,
                   void * source);
\end{verbatim}

   C'est cette fonction qu'invoquera une source pour lui notifier la
disponibilité d'une PDU. Cette fonction aura donc la responsabilité
d'aller récupérer la PDU (grâce à la fonction \lstinline!getPDU! et à la source
fournies) et de la traiter. La récupération et le traitement pourront
être remis à plus tard (en cas d'indisponibilité) mais au risque
d'avoir un pointeur \lstinline!NULL! retourné par \lstinline!getPDU()!. 

   Si le nom du module est {\tt toto}, la fonction sera nommée par exemple
{\tt toto\_processPDU()}.

   Alors là tu vas me dire ``qu'est-ce que c'est que ce chantier
?!''. En fait, voilà comment c'est censé fonctionner (et ça a l'air
de marcher !). Imaginons deux entités {\tt A} et {\tt B} de notre
réseau, {\tt B} étant en aval de {\tt A} comme dans la figure
\ref{figure:reseauAB}.

%.......................................................................
%
%.......................................................................
\subsubsection{Transmission d'une {\sc pdu}}

   Si, lors du traitement d'un événement, l'entité {\tt A} doit faire
suivre une {\sc pdu} à {\tt B}, elle le fera en invoquant la fonction
\lstinline!processPDU! associée à {\tt B}. À partir de ce moment, la
{\sc pdu} est sous la responsabilité de {\tt B}. Deux cas sont
envisageables : 

\begin{itemize}
   \item Soit {\tt B} est prète à traiter la {\tt pdu} (c'est une file
     non pleine, ou un serveur inactif par exemple), alors il invoque
     immédiatement (dans le code de son \lstinline!processPDU!) la
     fonction \lstinline!getPDU! de {\tt A} et tout va bien.
   \item Soit {\tt B} n'est pas prète. Dans le code de son
     \lstinline!processPDU!, il n'y aura donc pas d'invocation du
     \lstinline!getPDU! de {\tt A}, mais il devra y avoir une action
     permettant de le faire plus tard\footnote{En fait, ce n'est pas
       tout à fait vrai ! Il faut être certain que {\tt B} ira
       récupérer cette {\tt pdu}, mais on peut s'arranger autrement
       comme on va le voir avec l'arrivée d'une {\sc pdu}} (dans le temps simulé !), par
     exemple positioner un booléen quelconque. Mais d'ici à ce que
     cette invocation arrive, peut-être {\tt A} aura détruit la {\sc
       pdu} (imagine que {\tt A} modélise une couche physique, elle ne
     va pas retenir une {\sc pdu}, enfin, sois raisonable !
\end{itemize}

%.......................................................................
%
%.......................................................................
\subsubsection{Arrivée d'une {\sc pdu}}

   D'un autre côté, si, lors du traitement d'un événement, l'entité
{\tt B} est prête à consommer une {\sc pdu}, elle le fera en invoquant
la fonction \lstinline!getPDU! associée à {\tt A}.

   Là aussi, deux cas sont envisagables

\begin{itemize}
   \item Soit {\tt A} dispose effectivement d'une {\sc pdu} à fournir
     à {\tt B}, et dans ce cas là tout roule !
   \item Soit {\tt A} n'a pas de {\sc pdu}. Dans ce cas, la fonction
     \lstinline!getPDU! va renvoyer un pointeur \lstinline!NULL! qu'il
     vaut donc être prèt à traiter.
\end{itemize}

   L'invocatio de la fonction \lstinline!getPDU! de l'entité amont
peut donc être déclanchée par un événement qui n'a rien a voir avec
elle, c'est comme cela que l'on va aller chercher des {\sc pdu}s sans
y avoir été invité, d'où la note précédente, et d'où (entre autres) le
risque du pointeur \lstinline!NULL!.

%.......................................................................
%
%.......................................................................
\subsubsection{Chronologie des événements}

  Tout cela peut paraître un peu vicieux, et tu dois avoir du mal,
cher public, à voir quelle fonction utiliser quand ! Déjà,
rassure-toi, tout ça n'a besoin d'être maîtrisé que par celui qui veut
créer de nouveaux types d'entités pour le simulateur.

   D'autre part, c'est en fait très simple, il suffit de suivre la
logique des événements. Imaginons par exemple que tu veuilles
modéliser un ordonnanceur {\em round-robin}. On va supposer qu'il est
en aval d'un certain nombre de files, et en amont d'un serveur qui
modélise un lien de communication. Voir la figure
\ref{figure:exempleordo}.

% Figure

%
%
%
\paragraph{\lstinline!schedRRProcessPDU!}

   À quoi va ressembler le code de la fonction de traitement d'une
{\sc pdu} de cet ordonnanceur ? 

   Cette fonction sera invoquée lorsque l'une des files amont aura une
{\sc pdu} à fournir à l'ordonnanceur. Mais cette {\sc pdu} ne doit
être ordonnancée que si les deux conditions suivantes sont vérifiées :

\begin{itemize}
   \item le support (aval) est libre ;
   \item c'est au tour de cette file d'être servie ou les autres sont
     vides\footnote{Sinon il est non work conserving}.
\end{itemize}

   La fonction \lstinline!schedRRProcessPDU! va donc devoir tester ces
conditions et, si elles sont vraies, récupérer effectivement la {\sc
  pdu} (avec le \lstinline!getPDU! de la file) puis l'envoyer sur le
lien (avec le \lstinline!processPDU! du serveur). 

   Si les conditions ne sont pas vérifiées, alors elle laisse la {\sc
pdu} où elle est.

%
%
%
\paragraph{\lstinline!schedRRGetPDU!}

   Et maintenant à quoi ressemble la fonction d'obtention d'une {\sc
 pdu} de notre ordonnanceur ?

   Elle est invoquée par le support de communication (aval) lorsqu'il
est libre (un événement de fin de transmission de la précédente par
exemple).

   L'ordonnanceur ne dispose pas de {\sc pdu} lui même. Il doit donc
aller chercher dans les files amont la prochaine à servir et lui
prendre une {\sc pdu} par le biais de son \lstinline!getPDU!. S'il ne
trouve rien, il retourne un pointeur \lstinline!NULL! à l'entité aval
(le lien) qui ne fait donc rien.

   Dans cette situation le prochain événement sera l'arrivée d'une
{\sc pdu} dans une file par l'invocation de son \lstinline!processPDU!
qui invoquera celui de l'ordonnanceur, \ldots

%========================================================================
%
%========================================================================
\section{Le moteur de simulation}
\label{section:motsim}

%========================================================================
%
%========================================================================
\section{Les sondes}
\label{section:sondes}

   Les sondes sont implantées dans le modules {\tt probe}. Les sondes
permettent d'enregistrer des mesures de paramètres scalaires. Ce sont
elles qui permettront ensuite d'analyser le résultat de la simulation,
d'évaluer les performances du système, de tracer des courbes, \ldots

   Chaque échantillon d'une mesure prélevé par une sonde est daté. Il
est également possible de n'enregistrer que la date d'un événement,
sans aucune mesure associée.

   Les sondes peuvent être placées en divers points des outils de
simulation via des fonctions de la forme
\lstinline!<type>_add<point>Probe(...)!. Plusieurs sondes peuvent être
ainsi ``chaînées'' sur un même point de mesure. En revanche, la même
sonde {\bf ne peut pas} être chaînée plusieurs fois.

   Pour chacun des objets décrit dans ce fabuleux document, je
tâcherai de lister (dans une section''Les sondes'') les différents
points de mesure disponibles.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les méthodes de base}
\subsubsection{L'échantillonage}

   La méthode suivante permet d'échantilloner une valeur dans une
sonde 

\begin{verbatim}
/*
 * Echantillonage d'une valeur
 */
void probe_sample(struct probe_t * probe, double value);
\end{verbatim}

   Il est également possible d'échantilloner une date, sans valeur
associée, de la façon suivante 

\begin{verbatim}
/*
 * Echantillonage de la date d'occurence d'un evenement
 */
void probe_sampleEvent(struct probe_t * probe);
\end{verbatim}

\subsubsection{Consultation d'un échantillon}

\subsubsection{La moyenne}

\subsubsection{Les valeurs extrèmes}


\subsubsection{La sauvegarde}

   Une sonde peut être dumpée dans un fichier ouvert grâce à la
fonction

{\tt void probe\_graphBarDumpFd(struct probe\_t * probe, int fd, int
format);}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsubsection{La mesure du débit}

   Les valeurs échantillonées pourront souvent être des tailles de
messages, émis ou reçus. Dans ce cas, il peut être intéressant
d'utiliser la fonction suivante qui fournit une mesure du ``débit
instantané''.

\begin{verbatim}
double probe_throughput(struct probe_t * p);
\end{verbatim}

   Bien sûr, le mode d'estimation de cette valeur est dépendant de la
nature de la sonde.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les différents types}

\subsubsection{Les ``méta-sondes''}

   À chaque échantillon, certaines sondes mettent à jours des
informations que l'on peut souhaiter conserver (par exemple la moyenne
mobile) afin de tracer leur évolution dans le temps.

   Pour cela, une sonde périodique \lstinline!P! peut être placée sur
une sonde observée \lstinline!O!. La sonde \lstinline!P! permettra
ainsi d'observer une propriété de la sonde\lstinline!O! sur la base
d'un échantillonage à une fréquence caractérisant la sonde
\lstinline!P!. 

   Cette technique permet également de collecter dans une sonde unique
\lstinline!G! des échantillons prélevés dans plusieurs sondes
différentes \lstinline!S1!, \lstinline!S2!, ldots Pour cela,
\lstinline!G! sera ajoutée comme sonde sur les échantillons de
\lstinline!S1!, \lstinline!S2!, ldots 

\subsubsection{La sonde exhaustive}

\subsubsection{L'histogramme}

\subsubsection{La fenêtre glissante}

   Ces sondes conservent tous les échantillons sur une fenêtre
glissante dont la taille est fournie en paramêtre du constructeur :

\begin{verbatim}
struct probe_t * probe_slidingWindowCreate(int windowLength);
\end{verbatim}

\subsubsection{La sonde périodique}

   Le but d'une sonde périodique est de prélever un échantillon toutes
les $\tau$ unitées de temps. On se fonde pour cela sur l'idée que la
valeur mesurée n'est modifier qu'au cours du traitement d'un
événement.


\subsubsection{La moyenne mobile}

   Une moyenne du type \lstinline!EMAProbeType! conserve à tout moment
une moyenne mobile calculée à chaque nouvel échantillon $e$ de la façon
suivante $m <- \alpha . m + (1 - \alpha).e$.

\subsubsection{La moyenne par tranches temporelles}

   Cette sonde conserve une moyenne pour chaque tranche temporelle de
durée {\tt t}, passée en paramètre du constructeur (les fenêtres
temporelles sont sautantes donc disjointes):

\begin{verbatim}
struct probe_t * probe_createTimeAverage(double t);
\end{verbatim}


%========================================================================
%
%========================================================================
\section{Les {\sc pdu}s}
\label{section:pdu}

   La {\sc pdu} est l'objet de base échangé entre les entités du
simulateur. Si on voit considère deux entités homologues qui
dialoguent, il est effectivement légitime d'utiliser ce
terme. Cependant, dans une simulation réseau faite avec {\sc ndes}, la
notion d'entité est bien plus vaste que cela si bien que ce nom est
finalement mal choisi ! N'empèche que pour le moment, je vais le
conserver !

   Les {\sc pdu}s sont définies dans le fichier {\tt pdu.h} et
implantées dans le fichier {\tt pdu.c}. Une {\sc pdu} est une
structure extrèmement légère, dotée de quelques caractéristiques de
base : un identifiant, une taille, une date de création (dans le temps
simulé), et des données privées (un pointeur).

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les données privées}

%========================================================================
%
%========================================================================
\section{Les files}
\label{section:file}

   C'est l'outil de base pour stocker des objets selon une stratégie
{\sc fifo}. Elles sont définies dans le fichier {\tt file\_pdu.h} et
implantées dans le fichier {\tt file\_pdu.c}. Une file ne contient que
des {\sc pdu}s mais, comme on l'a vu, les {\sc pdu}s peuvent être
utilisées pour véhiculer tout et n'importe quoi grâce à leurs données
privées. Il est donc simple de construire des files de n'importe quoi !

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Création}

   Une file est créée de la façon suivante 

\begin{verbatim}
struct filePDU_t * filePDU_create(void * destination,
			    processPDU_t destProcessPDU);
\end{verbatim}

   Le paramètre \lstinline!destination! est un pointeur sur l'objet
vers lequel sont transmis les objets présents dans la file. Dés qu'un
objet est inséré dans la file, si la destination est disponible, il
lui est envoyé au travers de la fonction \lstinline!destProcessPDU!
passée en paramètre.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Gestion de la taille}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les sondes}

   Les files sont dotées des points de mesure suivants

\begin{description}
   \item[{\tt InsertSize}] pour mesurer la taille des paquets insérés
     dans la file. A chaque insertion d'une {\sc pdu}, la taille de
     cette dernière est échantillonée avec la date d'insertion.
   \item[{\tt ExtractSize}] pour mesurer la taille des paquets extraits
     de la file. A chaque extraction d'une {\sc pdu}, la taille de
     cette dernière est échantillonée avec la date d'extraction.
   \item[{\tt DropSize}]
   \item[{\tt Sejourn}]
\end{description}

   On peut ajouter une sonde sur chacun de ces points de mesure avec
une fonction de la forme

\begin{verbatim}
   void filePDU_add<measure>Probe(struct filePDU_t * file,
                                  struct probe_t   * probe);
\end{verbatim}

%========================================================================
%
%========================================================================
\section{Les générateurs aléatoires}
\label{section:rand-gen}

   Dans un simulateur, la génération de nombres aléatoires est un
élément important. Dans {\sc ndes}, on prend ces choses-là très au
sérieux. Du coup, la gestion des nombres aléatoires est une horreur
sans nom ! J'avoue avoir moi-même du mal à comprendre. La bonne
nouvelle c'est que du coup le résultat est vraiment \ldots{}
aléatoire.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Caractéristiques d'un générateur aléatoire}

   Un générateur aléatoire est caractérisé par trois composantes
fondamentales 

\begin{description}
   \item[Le type des données générées] peut être réel, entier,
     discret, \ldots
   \item[La loi] peut être uniforme, exponentielle, \ldots
   \item[La source] permet de déterminer la qualité de l'aléa, et par
     exemple de le rendre déterministe (afin d'obtenir la même
     séquence sur plusieurs simulation).
\end{description}

   Attention, ces trois composantes sont éventuellement constitutées
d'un jeu de paramètres.

   Le principe général de génération d'une valeur est le suivant.

\begin{itemize}
   \item Un nombre aléatoire est fourni par la source. Ce sera un
     entier entre deux valeurs extrèmes, par exemple, en fonction de
     la nature de la source.
   \item Une transformation est appliquée afin de respecter la
     densité de probabilité de la loi.
   \item Une seconde transformation est appliquée pour obtenir une
     valeur du type voulu.
\end{itemize}

   Bref, tout est fait pour laisser sa place au hasard \ldots


%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Utilisation}

   Le schéma général d'utilisation est simple : on crée un générateur,
on l'initialise avec le type de données voulu, on lui associe une
distribution, éventuellement on peut changer la source d'aléa sur
laquelle il se fonde, puis on peut lui extirper des valeurs aléatoires
et enfin on le détruit sans un mot de remerciement.

   Observons en détail les fonctions utiles à ce programme alléchant.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Création et destruction}

   Il existe au moins une fonction de création pour chaque type de
données géré (il manquerait plus que ça !). Mais il existe également
parfois des fonctions permettant de spécifier en même temps la
distribution à utiliser. Voyons ça type par type.

%.......................................................................
%
%.......................................................................
\subsubsection{Les entiers non signés}

   La fonction de création de base est 

\index{randomGenerator_createUInt}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUInt();
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Les entiers non signés entre {\tt min} et {\tt max} inclus}

   Ça c'est sympa pour jouer aux dés. On les crée avec 

\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntRange(unsigned int min,
						      unsigned int max);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Une liste d'entiers non signés}

   Pratique pour tirer au hasard des tailles de paquets !

\index{randomGenerator_createUIntDiscrete}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntDiscrete(int nbValues,
							      unsigned int * values);
\end{verbatim}

   Le premier paramètre donne le nombre de valeurs, et le second est
un tableau qui contient (au moins) ces valeurs. Son contenu sera
recopié, donc si tu veux le détruire/modifier ensuite, vis ta vie !

   Comme on se doute bien que dans ce genre de situations on va
vouloir associer une probabilité à chaque valeur, on peut utiliser la
version suivante :

\index{randomGenerator_createUIntDiscreteProba}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntDiscreteProba(
				int nbValues,
				unsigned int * values,
				double * proba);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Des réels double précision}

\begin{verbatim}
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Des réels double précision entre {\tt min} et {\tt max}}

\begin{verbatim}
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Une liste de réels double précision}

\begin{verbatim}
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Destruction}

   On détruit un générateur grâce à la fonction

\index{randomGenerator_delete}
\begin{verbatim}
void randomGenerator_delete(struct randomGenerator_t * rg);
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Choix de la loi}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Choix de la source}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Génération d'une valeur}

\index{randomGenerator_getNextUInt}
\index{randomGenerator_getNextDouble}

   Une nouvelle valeur est obtenue à chaque appel d'une des fonctions
suivantes (à choisir en fonction du type attendu)

\begin{verbatim}
unsigned int randomGenerator_getNextUInt(struct randomGenerator_t * rg);
double randomGenerator_getNextDouble(struct randomGenerator_t * rg);
\end{verbatim}

%========================================================================
%
%========================================================================
\section{Le serveur générique}
\label{section:srv_gen}

   Le serveur générique permet de modéliser à moindre frais un
serveur. Il est définit dans le fichier {\tt srv-gen.h}.

%========================================================================
%
%========================================================================
\section{Le puits}
\label{section:puits}

%========================================================================
%
%========================================================================
\section{L'affichage par GnuPlot}
\label{section:gnuplot}

%========================================================================
%
%========================================================================
\section{Notion de simulation et de campagne}

   Une simulation est une instance unique d'exécution d'une séquence
d'événements suite à l'initialisation du modèle. Une campagne est une
suite de simulations sur un même modèle avec une ré-initialisation des
variables entre deus simulations.

   Les sondes liées à la simulation sont ré-initialisées à la fin de
la simulation. Des sondes peuvent être liées à la campagne ; elles ne
seront réinitialisées qu'à la fin de cette dernière et peuvent
permettre ainsi à établir des valeurs inter-simulation, par exemple
des intervalles de confiance.


\section{Des exemples}

\subsection{Utilisation des sondes}

\subsubsection{Mesurer un débit}

   Considérons le cas simple d'une source, dont nous voulons mesurer
le débit de sortie. Pour cela, nous allons insérer une sonde sur la
taille des paquets transmis grâce à la méthode {\tt
  PDUSource\_setPDUGenerationSizeProbe}.

   Le type de sonde dépendra de la mesure souhaitée.

\paragraph{Débit moyen}

   Supposons que nous voulons simplement connaître le débit moyen sur
toute la transmission, alors une sonde mesurant la moyenne sera parfaitement
suffisante :

\paragraph{Débit ``instantanté''}


\end{document}
