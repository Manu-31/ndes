\documentclass{article}

\usepackage[utf8x]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{srcltx}
\usepackage{listings}
\usepackage[pdftex]{thumbpdf}
\usepackage[pdftex,colorlinks]{hyperref}
\usepackage{index}

\title{Network Discrete Event Simulator\\guide de l'utilisateur\\guide du programmeur}

\author{Emmanuel Chaput}

\makeindex

\begin{document}
\maketitle

\begin{abstract}
   {\em Network Discrete Event Simulator} (ou {\sc ndes}) est une
librairie permettant de construire des simulateurs réseaux à
événements discret. Ce document est à la fois un guide de
l'utilisateur et un guide du programmeur de cet outil.

   {\sc Ndes} a été essentiellement conçu dans le but de simuler un
scénario spécifique (l'ordonnancement de paquets sur un lien
DVB-S2). Mais il intègre également diverses portions de code de
l'auteur qui avaient d'autres buts. Son utilisation dans un contexte
différent reste cependant très difficile, en particulier du fait de
l'absence d'une librairie de modèles conséquente.
\end{abstract}

\newpage
\tableofcontents
\newpage


%========================================================================
%
%========================================================================
\section{Introduction générale}

   {\em Network Discrete Event Simulator} (ou {\sc ndes}) est une
librairie permettant de construire des simulateurs réseaux à
événements discret. Cette librairie peut être utilisée à différentes
fins. Nous classerons les individus en deux catégories en fonction de
leurs objectifs.

\begin{description}
   \item[Un utilisateur] est une personne souhaitant écrire un
     programme de simulation fondé sur cette librairie. Il n'a besoin
     que de la version compilée de cette librairie. Il ne lui est pas
     nécessaire d'en connaître les détails de fonctionnement.
   \item[Un programmeur] est une personne visant à améliorer, enrichir
     ou déboguer cette librairie. Il a donc besoin de manipuler le
     code source et, pour cela, d'en comprendre le fonctionnement.
\end{description}

   La distinction est importante pour la suite du
document.

   L'utilisateur pourra commencer par lire la section
\ref{section:user-tuto} qui présente l'utilisation du simulateur sous
la forme d'un tutoriel (dont le code est fourni avec les source de
{\sc ndes}). Il pourra ensuite consulter les sections présentant les
outils du simulateur (les sondes, les générateurs, \ldots) et la
librairie des modèles.

   Le programmeur, quant à lui, devra lire la section dédiée à
l'extension du simulateur, là aussi présentée sous la forme d'un
tutoriel, puis consulter les sections décrivant les arcanes de {\sc
  ndes} telles que le moteur de simulation.

   Comme souvent dans ce genre de projet, malheureusement, il est
illusoire d'espérer une documentation à jour. L'objectif est avant
tout de développer l'outil afin d'en améliorer l'usage ciblé que de
maintenir une documentation. Le lecteur est donc invité à consulter
les sources suivantes d'information, dans l'ordre inverse de fraîcheur
:

\begin{itemize}
   \item ce document ;
   \item la documentation extraite par doxygen des sources et présente
     dans le répertoire {\tt DOCS} ;
   \item le code source.
\end{itemize}

   
%========================================================================
%
%========================================================================
\section{Tutoriel}
\label{section:user-tuto}

%------------------------------------------------------------------------
\subsection{Introduction}

   Félicitations ! Tu t'apprètes à entrer dans le monde fabuleux de
{\sc ndes}, \ldots

   Il s'agit en gros d'une sorte de librairie astucieusement
agrémentée de nombreux bugs dont le but et de t'aider (ou pas) à faire
ton propre simulateur réseau !

   L'implantation d'un simulateur passera donc par l'écriture d'un
programme C utilisant cette librairie.

%------------------------------------------------------------------------
\subsection{Installation}

\begin{verbatim}
 $ git clone https://github.com/Manu-31/ndes.git
 $ cd ndes
 $ make
 $ make install
\end{verbatim}

   Pas de panique, ça n'installe rien pour le moment ! Cela ne fait
que copier une librairie (statique) dans un répertoire dédié dans
l'arborescence.

   On peut également compiler quelques programmes de tests de non
régression :

\begin{verbatim}
 $ make tests-bin
\end{verbatim}
%$
   Et pourquoi pas les lancer :

\begin{verbatim}
 $ make tests
\end{verbatim}
%$

   Évidemment, les messages {\tt OK} ne prouvent rien ! Seuls les
messages d'erreur prouvent qu'il y a un problème, \ldots {} comme s'il
y avait besoin de preuves.

%------------------------------------------------------------------------
\subsection{Ma première simulation : chouette, une file M/M/1 !}

   Le fichier source (et son Makefile, parce qu'on ne se moque pas du
client) se trouve dans le répertoire {\tt example/tutorial-1}.

   Dans {\sc ndes}, le système va être modélisé par une source, suivie
d'une file d'attente, en aval de laquelle se trouve un serveur suivi
par un puits. Je te laisse faire un dessin et je publierai ici le plus
joli !

%........................................................................
\subsubsection{Création du simulateur}

   Avant toute manipulation, on crée le simulateur de la façon suivante

\begin{verbatim}
#include <motsim.h>

...

   /* Creation du simulateur */
   motSim_create();
\end{verbatim}

%........................................................................
\subsubsection{Création du puits}

   Un puits sera un objet qui reçoit sans rechigner des messages et
qui les détruit instantanément. On le crée très simplement de la façon
suivante

\begin{verbatim}
#include <pdu-sink.h>

...

   struct PDUSink_t       * sink; // Déclaration d'un puits

   ...

   /* Crétion du puits */
   sink = PDUSink_create();
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Création du serveur}

   Dans la mesure où on ne souhaite rien faire de bien intelligent
avec notre serveur, nous allons utiliser un serveur générique, offert
par la maison, qui ne recule devant aucun sacrifice !

   Il s'utilise comme ça 

\begin{verbatim}
#include <srv-gen.h>

...

   struct srvGen_t        * serveur; // Déclaration d'un serveur générique

...

   /* Création du serveur */
   serveur = srvGen_create(sink, (processPDU_t)PDUSink_processPDU);
\end{verbatim}

   La création du serveur est un peu plus compliquée que celle du
puits. La raison est que le serveur doit savoir à qui envoyer les
clients (des {\sc pdu}s pour {\sc ndes}) après les avoir servis. Il
faut donc lui dire quelle fonction leur appliquer (ici {\tt
  PDUSink\_processPDU} un fonction spécifiques aux puits) et à quelle
entité cette fonction s'applique (notre unique puits, ici). Pour
connaître   la fonction, il faut la chercher dans la description de
l'entité cible. Dans notre exemple, la fonction {\tt
  PDUSink\_processPDU} est décrite dans la section dédiée aux puits.

   Plus de précisions sur cette histoire de fonctions dans la section
\ref{section:architecture} de description de l'architecture générale.

   Comme nous voulons une file M/M/1, nous devons dire à notre serveur
que son temps de traitement est exponentiel de paramètre {\tt mu}. Et
zou :

\begin{verbatim}
   float   mu = 10.0; // Paramètre du serveur

   ...

   /* Paramétrage du serveur */
   srvGen_setServiceTime(serveur, serviceTimeExp, mu);
\end{verbatim}

   Les serveurs génériques sont décrits plus précisément dans la
section \ref{section:srv_gen}.

%........................................................................
%
%........................................................................
\subsubsection{Création de la file}

   Une file permet de stocker des {\sc pdu} en transit. On la
construit ainsi

\begin{verbatim}
   struct filePDU_t       * filePDU; // Déclaration de notre file

    ...

   /* Création de la file */
   filePDU = filePDU_create(serveur, (processPDU_t)srvGen_processPDU);
\end{verbatim}

   Sans autre forme de procès, les files ne sont pas bornées. Elles
sont décrites plus précisément dans la section \ref{section:file}. Les
deux paramètres de la fonction de création ont le même rôle que ceux
de la fonction de création du serveur.

%........................................................................
%
%........................................................................
\subsubsection{Création de la source}

   Nous voilà à la source ! Nous allons utiliser un objet de {\sc
ndes} dont le rôle est de produire des {\sc pdu}s. Mais avant cela,
nous devons créer un autre objet qui lui indiquera les dates
auxquelles les produire : il s'agit d'un ``générateur de date'',
original, non ? Les générateurs de dates sont décrits dans la section \ref{section:date_generator}.

   On veut une source poisonnienne, donc un générateur exponentiel :

\begin{verbatim}
#include <date-generator.h>

...

   struct dateGenerator_t * dateGenExp; // Un générateur de dates
   float   lambda = 5.0 ; // Intensité du processus d'arrivée

   ...

   /* Création d'un générateur de date */
   dateGenExp = dateGenerator_createExp(lambda);
\end{verbatim}

   Et maintenant nous pouvons donc créer notre source :

\begin{verbatim}
#include <pdu-source.h>

...

   struct PDUSource_t     * sourcePDU;  // Une source

   ...

   sourcePDU = PDUSource_create(dateGenExp, 
				filePDU,
				(processPDU_t)filePDU_processPDU);
\end{verbatim}

   Le premier paramètre est donc l'objet qui lui permet de déterminer
les dates d'envoi. Les deux suivants sont similaires à ceux passés
lors de la cration de la file et du serveur.
   
%........................................................................
%
%........................................................................
\subsubsection{Mise en place de sondes}

   Oui, je sais, le titre fait un peu peur, mais ça va bien se
passer. Lorsqu'on veut lancer un simulateur, on espère en général
obtenir des résulats. Dans {\sc ndes}, ceux-ci seront collectés par un
outil spécifique, la sonde.

   Les différents types de sonde sont décrits dans la section
\ref{section:sondes}. Nous utiliserons ici uniquement des sondes
exhaustives. Pour chaque objet décrit, la liste des sondes
disponibles est fournie. 

   Nous les déclarons et initialisons comme ça :

\begin{verbatim}
#include <probe.h>

...

   struct probe_t         * sejProbe, * iaProbe, * srvProbe; // Les sondes

...

   /* Une sonde sur les interarrivées */
   iaProbe = probe_createExhaustive();
   dateGenerator_setInterArrivalProbe(dateGenExp, iaProbe);

   /* Une sonde sur les temps de séjour */
   sejProbe = probe_createExhaustive();
   filePDU_addSejournProbe(filePDU, sejProbe);

   /* Une sonde sur les temps de service */
   srvProbe = probe_createExhaustive();
   srvGen_setServiceProbe(serveur, srvProbe);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Lancement de la simulation}

   Ça y est, nous y sommes enfin, voici comment démarrer la
simulation. Nous devons activer les entités voulue au moment
voulu. Ici, il n'y a que l'unique source à activer, et nous souhaitons
le faire dès le début de la simulation :

\begin{verbatim}
   /* On active la source */
   PDUSource_start(sourcePDU);
\end{verbatim}

   Nous lançons maintenant la simulation. Nous allons la faire durer
100 secondes :

\begin{verbatim}
   /* C'est parti pour 100 000 millisecondes de temps simulé */
   motSim_runUntil(100000.0);
\end{verbatim}

   Nous pouvons ensuite afficher quelques paramètres internes du
simulateur :

\begin{verbatim}
   motSim_printStatus();
\end{verbatim}

   Et voilà !

%........................................................................
%
%........................................................................
\subsubsection{Affichage des résultats}

   Maintenant que notre simulation est terminée, on a certainement 
envie d'en voir le résultat. On utilisera pour cela des fonctions
founies par les sondes, par exemple :

\begin{verbatim}
   /* Affichage de quelques résultats scalaires */
   printf("%d paquets restant dans  la file\n",
	  filePDU_length(filePDU));
   printf("Temps moyen de sejour dans la file = %f\n",
	  probe_mean(sejProbe));
   printf("Interarive moyenne     = %f (1/lambda = %f)\n",
	  probe_mean(iaProbe), 1.0/lambda);
   printf("Temps de service moyen = %f (1/mu     = %f)\n",
	  probe_mean(srvProbe), 1.0/mu);
\end{verbatim}

   Génial, non ? Non ! Mais la suite est plus rigolote, \ldots

%........................................................................
%
%........................................................................
\subsubsection{Tracé de courbes}

   Pour obtenir des résultats plus riches, nous allons utiliser
(depuis le simulateur) un affichage {\em gnuplot}. Nous avons ici au
moins deux courbes intéressantes à tracer, donc nous allons écrire une
 fonction pour cela :

\begin{verbatim}

/*
 * Affichage (via gnuplot) de la probre pr
 * elle sera affichée comme un graphbar de nbBar barres
 * avec le nom name
 */
void tracer(struct probe_t * pr, char * name, int nbBar)
{
   struct probe_t   * gb;
   struct gnuplot_t * gp;

   /* On crée une sonde de type GraphBar */
   gb = probe_createGraphBar(probe_min(pr), probe_max(pr), nbBar);

   /* On convertit la sonde passée en paramètre en GraphBar */
   probe_exhaustiveToGraphBar(pr, gb);

   /* On la baptise */
   probe_setName(gb, name);

   /* On initialise une section gnuplot */
   gp = gnuplot_create();

   /* On recadre les choses */
   gnuplot_setXRange(gp, probe_min(gb), probe_max(gb)/2.0);

   /* On affiche */
   gnuplot_displayProbe(gp, WITH_BOXES, gb);
}
\end{verbatim}

   L'utilisation de {\em gnuplot} est décrite dans la section
\ref{section:gnuplot}.

   Attention à ne pas oublier de mettre une petite pause à la fin de
notre programme principal, sinon il s'arrète et il tue ses processus
fils, et donc l'affichage {\rm gnuplot} disparaît.

%........................................................................
%
%........................................................................
\subsubsection{Utilisation de notre premier simulateur}

   Il ne nous reste plus qu'à compiler notre programme et à le
lancer. Le répertoire {\tt examples/tutorial-1} contient également un
makefile que je te laisse observer, mais en gros, il faut aller
chercher les includes et la librairie. En utilisant ce {\tt Makefile},
on a donc :

\begin{verbatim}
 $ cd examples/tutorial-1
 $ make
 $ ./mm1
[MOTSI] Date = 99999.846555
[MOTSI] Events : 998243 created (3 m + 998240 r)/998242 freed
[MOTSI] Simulated events : 998243 in, 998242 out, 1 pr.
[MOTSI] PDU : 998242 created (27 m + 998215 r)/998242 freed
[MOTSI] Total malloc'ed memory : 25169976 bytes
[MOTSI] Realtime duration : 1 sec
0 paquets restant dans  la file
Temps moyen de sejour dans la file = 0.061008
Interarive moyenne     = 0.200352 (1/lambda = 0.200000)
Temps de service moyen = 0.100176 (1/mu     = 0.100000)
*** ^C pour finir ;-)
 $
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Ma deuxiéme simulation : super, encore une file M/M/1 !}

   Le premier exemple est sympa, vas-tu me dire, mais ce serait mieux
si le temps de traitement dépendait de la taille des clients (comme
des paquets dont le temps d'émission dépend de la taille !)

   Et bien soit ! C'est ce que nous allons faire dans ce deuxième
tutoriel. Les fichiers se trouvent dans le répertoire {\tt
example/tutorial-2}.

   Comme je n'ai pas que ça à faire, et toi non plus probablement, je
vais juste commenter les différences par rapport au tutoriel
précédent.

   Une petite modification cosmétique est apportée dans la définition
des paramètres de la simulation, que l'on va présenter avec un
vocabulaire plus réseau et moins file d'attente :

\begin{verbatim}
   float frequencePaquets = 5.0;      // Nombre moyen de pq/s
   float tailleMoyenne    = 1000.0;   // Taille moyenne des pq
   float debit            = 10000.0;  // En bit par seconde
\end{verbatim}

   Ces valeurs sont peu réalistes, mais choisies astucieusement pour
avoir les mêmes résultats que le premier tutoriel.

%........................................................................
%
%........................................................................
\subsubsection{Génération de la taille des paquets}

   Voilà la principale différence avec le premier tutoriel. On va
utiliser un générateur de nombres aléatoires pour avoir des paquets de
taille variable :

\begin{verbatim}
   /* Création d'un générateur de taille (tailles non bornées) */
   sizeGen = randomGenerator_createUInt();
   randomGenerator_setDistributionExp(sizeGen, 1.0/tailleMoyenne);

   /* Affectation à la source */
   PDUSource_setPDUSizeGenerator(sourcePDU, sizeGen);
\end{verbatim}

  Les générateurs de nombres aléatoires sont décrits dans la section
\ref{section:rand-gen}. Profitons en pour placer une sonde sur cette
taille, afin de vérifier qu'elle a bien la bonne tête :

\begin{verbatim}
   /* Une sonde sur les tailles */
   szProbe = probe_createExhaustive();
   randomGenerator_setValueProbe(sizeGen, szProbe);
\end{verbatim}

   Avec ça, on pourra tracer une jolie courbe de plus !

%........................................................................
%
%........................................................................
\subsubsection{Prise en compte par le serveur}

   Ce que l'on vient de faire ne sert à rien si le serveur ne le prend
pas en compte. Il nous faut donc préciser que ce dernier sert chaque
client en un temps dépendant de la taille :

\begin{verbatim}
   /* Paramétrage du serveur */
   srvGen_setServiceTime(serveur, serviceTimeProp, 1.0/debit);
\end{verbatim}

   Cela signifie que le temps de service d'un client est proportionnel
à sa taille avec comme coefficient l'inverse du débit.

%========================================================================
%
%========================================================================
\section{L'architecture générale}
\label{section:architecture}

   Le but de cette section est de décrire la logique de {\sc
ndes}.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Type de simulation}

   {\sc Ndes} est une librairie de simulation de réseaux par événements
discrets. Non, ce n'est pas original, mais c'est tout de même
vachement important pour la suite. Tout le code de traitement d'un
événement que l'on va écrire sera exécuté en une durée éventuelllement
super longue, mais absolument pas comptabilisé dans le temps
simulé. Et pire ! Pendant le traitement d'un événement, comme le temps
simulé est figé, le système n'évolue pas (sauf au travers du code en
question). C'est du connu, d'accord, mais c'est lourd de conséquences
(musique stressante).

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Schéma général des modèles}

   L'idée fondamentale est que le réseau à simuler peut être
modélisé comme une suite d'entitées chaînées entre elles. Dans la
version la plus simple, strictement linéaire, la première de ces
entités va produire des messages, nommés {\sc pdu}s, qu'elle fera
suivre à l'entité suivante et ainsi de suite jusqu'à la dernière qui
pourra sonserver les messages ou les détruire.

   La file M/M/1 décrite dans le premier tutoriel est un parfait
exemple de ce modèle. Nous connaissons donc déjà quatre types de
noeuds : {\tt sourcePDU}, {\tt filePDU}, {\tt serv\_gen} et {\tt PDUSink}.

   La construction du réseau se fait en partant ``de la fin'' et en
remontant vers la source, comme on peut le voir dans le
tutoriel. Chaque fois que l'on crée une entité, on doit lui passer
comme paramètres des informations sur l'entité en aval. Elle n'a, en
revanche, aucun besoin de connaître la ou les entités amont. Oui, il
peut y en avoir plusieurs.

   Certaines entités peuvent également avoir plusieurs entités aval
(qui seront fournies par une fonction spécifique), mais une {\sc pdu}
donnée n'est passée qu'à une seule d'entre elles.

   La mauvaise nouvelle, c'est que que ce schéma va être à revoir tôt
ou tard ! Il n'est pas génial pour modéliser des choses plus
symétriques (une entité protocolaire qui émet et reçoit), et des
choses sont à revoir comme le terme de {\sc pdu} qui n'est pas du tout
approprié. Ce ne sont pas que des {\sc pdu} qui sont représentées par
cette chose !

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Fonctions d'échange des {\sc pdu}}

   Du fait de l'architecture générale du réseau, pour toute entité susceptible
de produire ou transférer des PDU doit exister une fonction de la forme

\begin{verbatim}
   struct PDU_t * getPDU(void * source);
\end{verbatim}

   Le paramètre est un pointeur vers des "données privées" permettant
d'identifier le noeud (typiquement un pointeur direct sur ce noeud).

   Le pointeur retourné est celui d'une PDU qui n'est plus prise en
compte par la source. Elle doit donc absolument être gérée (ou, au
moins, détruite) par l'utilisateur de cette fonction. En cas
d'indisponibilité de PDU, la valeur {\tt NULL} est retournée.

   Cette fonction et le pointeur associé doivent être fournis à
l'entité destinataire, s'il en existe une !

   Si le nom du module est {\tt toto}, la fonction sera nommée par exemple
{\tt toto\_getPDU().}\\

   Symétriquement, tout module susceptible de recevoir des PDU doit fournir une
fonction de la forme :


\begin{verbatim}
   int processPDU(void * rec,
                  getPDU\_t getPDU,
                  void * source);
\end{verbatim}

   C'est cette fonction qu'invoquera une source pour lui notifier la
disponibilité d'une PDU. Cette fonction aura donc la responsabilité
d'aller récupérer la PDU (grâce à la fonction \lstinline!getPDU! et à la source
fournies) et de la traiter. La récupération et le traitement pourront
être remis à plus tard (en cas d'indisponibilité) mais au risque
d'avoir un pointeur \lstinline!NULL! retourné par
\lstinline!getPDU()!.

   La valeur de retour de cette fonction est nulle en cas d'échec, et
non nulle en cas de succès.

   Cette fonction peut être invoquée avec les deux derniers paramètres
{\tt NULL}. Dans ce cas, l'objectif est uniquement de déterminer si
l'entité {\tt rec} est disposée à traiter une nouvelle {\sc pdu}. Elle
doit donc renvoyer 0 ou 1 si elle est occupée ou libre,
respectivement. 

   Cette propriété doit être implantée dans tous les cas et pourra
être utilisée par exemple par une entité amont qui peut conserver les
{\sc pdu}s (une file par exemple) afin d'éviter une perte dûe à une
entité aval qui ne pourrait pas recevoir une nouvelle {\sc pdu} (un
lien en cours de  transmission par exemple).

   Un exemple d'utilisation est donné dans le premier ''{\em Tutoriel
     du programmeur}'' en sous-section \ref{subsection:tut-ordo}.

   Si le nom du module est {\tt toto}, la fonction sera nommée par exemple
{\tt toto\_processPDU()}.

   Alors là tu vas me dire ``qu'est-ce que c'est que ce chantier
?!''. En fait, voilà comment c'est censé fonctionner (et ça a l'air
de marcher !). Imaginons deux entités {\tt A} et {\tt B} de notre
réseau, {\tt B} étant en aval de {\tt A} comme dans la figure
\ref{figure:reseauAB}.

%.......................................................................
%
%.......................................................................
\subsubsection{Transmission d'une {\sc pdu}}

   Si, lors du traitement d'un événement, l'entité {\tt A} doit faire
suivre une {\sc pdu} à {\tt B}, elle le fera en invoquant la fonction
\lstinline!processPDU! associée à {\tt B}. À partir de ce moment, la
{\sc pdu} est sous la responsabilité de {\tt B}. Deux cas sont
envisageables : 

\begin{itemize}
   \item Soit {\tt B} est prète à traiter la {\tt pdu} (c'est une file
     non pleine, ou un serveur inactif par exemple), alors il invoque
     immédiatement (dans le code de son \lstinline!processPDU!) la
     fonction \lstinline!getPDU! de {\tt A} et tout va bien.
   \item Soit {\tt B} n'est pas prète. Dans le code de son
     \lstinline!processPDU!, il n'y aura donc pas d'invocation du
     \lstinline!getPDU! de {\tt A}, mais il devra y avoir une action
     permettant de le faire plus tard\footnote{En fait, ce n'est pas
       tout à fait vrai ! Il faut être certain que {\tt B} ira
       récupérer cette {\tt pdu}, mais on peut s'arranger autrement
       comme on va le voir avec l'arrivée d'une {\sc pdu}} (dans le temps simulé !), par
     exemple positioner un booléen quelconque. Mais d'ici à ce que
     cette invocation arrive, peut-être {\tt A} aura détruit la {\sc
       pdu} (imagine que {\tt A} modélise une couche physique, elle ne
     va pas retenir une {\sc pdu}, enfin, sois raisonable !
\end{itemize}

%.......................................................................
%
%.......................................................................
\subsubsection{Arrivée d'une {\sc pdu}}

   D'un autre côté, si, lors du traitement d'un événement, l'entité
{\tt B} est prête à consommer une {\sc pdu}, elle le fera en invoquant
la fonction \lstinline!getPDU! associée à {\tt A}.

   Là aussi, deux cas sont envisagables

\begin{itemize}
   \item Soit {\tt A} dispose effectivement d'une {\sc pdu} à fournir
     à {\tt B}, et dans ce cas là tout roule !
   \item Soit {\tt A} n'a pas de {\sc pdu}. Dans ce cas, la fonction
     \lstinline!getPDU! va renvoyer un pointeur \lstinline!NULL! qu'il
     vaut donc être prèt à traiter.
\end{itemize}

   L'invocatio de la fonction \lstinline!getPDU! de l'entité amont
peut donc être déclanchée par un événement qui n'a rien a voir avec
elle, c'est comme cela que l'on va aller chercher des {\sc pdu}s sans
y avoir été invité, d'où la note précédente, et d'où (entre autres) le
risque du pointeur \lstinline!NULL!.

%.......................................................................
%
%.......................................................................
\subsubsection{Chronologie des événements}

  Tout cela peut paraître un peu vicieux, et tu dois avoir du mal,
cher public, à voir quelle fonction utiliser quand ! Déjà,
rassure-toi, tout ça n'a besoin d'être maîtrisé que par celui qui veut
créer de nouveaux types d'entités pour le simulateur.

   D'autre part, c'est en fait très simple, il suffit de suivre la
logique des événements. Imaginons par exemple que tu veuilles
modéliser un ordonnanceur {\em round-robin}. On va supposer qu'il est
en aval d'un certain nombre de files, et en amont d'un serveur qui
modélise un lien de communication. Voir la figure
\ref{figure:exempleordo}.

% Figure

%
%
%
\paragraph{\lstinline!schedRRProcessPDU!}

   À quoi va ressembler le code de la fonction de traitement d'une
{\sc pdu} de cet ordonnanceur ? 

   Cette fonction sera invoquée lorsque l'une des files amont aura une
{\sc pdu} à fournir à l'ordonnanceur. Mais cette {\sc pdu} ne doit
être ordonnancée que si les deux conditions suivantes sont vérifiées :

\begin{itemize}
   \item le support (aval) est libre ;
   \item c'est au tour de cette file d'être servie ou les autres sont
     vides\footnote{Sinon il est non work conserving}.
\end{itemize}

   La fonction \lstinline!schedRRProcessPDU! va donc devoir tester ces
conditions et, si elles sont vraies, récupérer effectivement la {\sc
  pdu} (avec le \lstinline!getPDU! de la file) puis l'envoyer sur le
lien (avec le \lstinline!processPDU! du serveur). 

   Si les conditions ne sont pas vérifiées, alors elle laisse la {\sc
pdu} où elle est.

%
%
%
\paragraph{\lstinline!schedRRGetPDU!}

   Et maintenant à quoi ressemble la fonction d'obtention d'une {\sc
 pdu} de notre ordonnanceur ?

   Elle est invoquée par le support de communication (aval) lorsqu'il
est libre (un événement de fin de transmission de la précédente par
exemple).

   L'ordonnanceur ne dispose pas de {\sc pdu} lui même. Il doit donc
aller chercher dans les files amont la prochaine à servir et lui
prendre une {\sc pdu} par le biais de son \lstinline!getPDU!. S'il ne
trouve rien, il retourne un pointeur \lstinline!NULL! à l'entité aval
(le lien) qui ne fait donc rien.

   Dans cette situation le prochain événement sera l'arrivée d'une
{\sc pdu} dans une file par l'invocation de son \lstinline!processPDU!
qui invoquera celui de l'ordonnanceur, \ldots

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Plusieurs émetteurs vers le même destinataire}

   Comment faire lorsque plusieurs entités sont en amont d'une même
entitée aval ? Par exemple plusieurs sources qui envoient des clients
vers un unique serveur.

   En fait, ce n'est pas fondamentalement un problème en soit, dans la
mesure ou l'entité aval n'a en général pas à connaître l'entité
amont. Du coup, s'il y en a deux ou plus, elle s'en moque. Oui, sauf
que non ! Imagine une entité qui n'est pas toujours disposée à traiter
une {\sc pdu} entrante. En général, elle va stocker quelque part une
information qui lui permettra de venir chercher la {\sc pdu} quand
elle le voudra bien. Si ce phénomène se produit plusieurs fois avant
que l'entité soit disposée à enfin traiter les {\sc pdu}s en attente,
seule la dernière risque d'avoir été mémorisée !

   Du coup, on pourrait être tenté de faire une liste chaînée de ces 
événements, de sorte à n'en rater aucun. Malheureusement, cela met
nécessairement en place une politique {\sc fcfs}, alors qu'on peut
souhaiter implanter autre chose.

%========================================================================
%
%========================================================================
\section{Extension du simulateur}
\label{section:extension}


%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Réalisation d'un ordonnanceur}
\label{subsection:tut-ordo}

   À titre d'exemple, nous allons implanter un ordonnanceur {\em Round
Robin}. Les fichiers source et {\tt Makefile} sont dans le
répertoire {\tt tuto-prog-1}.

%........................................................................
%
%........................................................................
\subsubsection{Caractéristiques de l'ordonnanceur}

   Passons sur les {\tt include} et regardons comment caratériser un
ordonnanceur :

\begin{verbatim}
#define SCHED_RR_NB_INPUT_MAX 8

struct rrSched_t {
   // La destination (typiquement un lien)
   void         * destination;
   processPDU_t   destProcessPDU;

   // Les sources (files d'entrée)
   int        nbSources;
   void     * sources[SCHED_RR_NB_INPUT_MAX];
   getPDU_t   srcGetPDU[SCHED_RR_NB_INPUT_MAX];

   // La dernière source servie par le tourniquet
   int lastServed;
};
\end{verbatim}

   Il nous faut connaître les entités amont, puisque nous voulons les
traiter séparément !

   La fonction de création est assez simple :

\index{rrSched\_create}
\begin{verbatim}
struct rrSched_t * rrSched_create(void * destination,
				  processPDU_t destProcessPDU)
{
   struct rrSched_t * result = (struct rrSched_t * )sim_malloc(sizeof(struct rrSched_t));

   // Gestion de la destination
   result->destination = destination;
   result->destProcessPDU = destProcessPDU;

   // Pas de source définie
   result->nbSources = 0;

   // On commence quelquepart ...
   result->lastServed = 0;

   return result;
}
\end{verbatim}

   On gère la destination, comme toute entité qui peut fournir des
{\sc psu}s doit le faire, et on s'occupe de ses spécificités.

    Une source sera par exemple attribuée de la façon suivante :

\index{rrSched\_addSource}
\begin{verbatim}
void rrSched_addSource(struct rrSched_t * sched,
		       void * source,
		       getPDU_t getPDU)
{
   assert(sched->nbSources < SCHED_RR_NB_INPUT_MAX);

   sched->sources[sched->nbSources] = source;
   sched->srcGetPDU[sched->nbSources++] = getPDU;
}
\end{verbatim}

   Attention, ce n'est pas très robuste ! Mais ce n'est pas l'onjectif
ici, \ldots

%........................................................................
%
%........................................................................
\subsubsection{La fonction {\tt rrSched\_getPDU}}

   C'est cette fonction qui est invoquée par l'entité aval pour
obtenir une {\sc pdu}. C'est dans cette fonction que nous allons donc
implanter l'algorithme d'ordonnancement.

   En voici le code

\index{rrSched\_getPDU}
\begin{verbatim}
struct PDU_t * rrSched_getPDU(void * s)
{
   struct rrSched_t * sched = (struct rrSched_t * )s;
   struct PDU_t * result = NULL;

   assert(sched->nbSources > 0);

   int next = sched->lastServed;

   // Quelle est la prochaine source à servir ?
   do {
      // On cherche depuis la prochaine la première source qui a des
      // choses à nous donner
      next = (next + 1)%sched->nbSources;
      result = sched->srcGetPDU[next](sched->sources[next]);
   } while ((result == NULL) && (next != sched->lastServed));

   if (result)
     sched->lastServed = next;
   return result;
}
\end{verbatim}

   En fait, il n'y a pas grand-chose à en dire ! On applique
l'algorithme d'ordonnancement, et on fournit une {\sc pdu},
éventuellement {\tt NULL} s'il n'y a rien à ordonnancer.

%........................................................................
%
%........................................................................
\subsubsection{La fonction {\tt rrSched\_processPDU}}

   Plus rigolo, passons à la fonction {\tt rrSched\_processPDU} qui
sera invoquée par une source qui dispose d'une {\sc pdu} et qui
souhaite la faire passer à l'ordonnanceur.

   Celui-ci devra la traiter s'il le peut, mais ne pas la prendre s'il
ne peut pas la traiter. Voici le début de la fonction

\index{rrSched\_processPDU}
\begin{verbatim}
int rrSched_processPDU(void *s,
		       getPDU_t getPDU,
		       void * source)
{
   int result;
   struct rrSched_t * sched = (struct rrSched_t *)s;

   printf_debug(DEBUG_SCHED, "in\n");
\end{verbatim}

   J'ai utiliser la fonction de débogage à titre d'exemple. Il y en a
d'autres dans le fichier source. On se contente ici d'un {\em cast}
pour respecter le prototype des fonctions d'échange.

   La première chose à faire est de vérifier la disponibilité de
l'entité aval :

\begin{verbatim}
   // La destination est-elle prete ?
   int destDispo = sched->destProcessPDU(sched->destination, NULL, NULL);
\end{verbatim}

   Maintenant nous allons traiter le cas du test (paramètres {\tt
NULL} pour tester notre disponibilité) :

\begin{verbatim}
   // Si c'est un test de dispo, je dépend de l'aval
   if ((getPDU == NULL) || (source == NULL)) {
      result = destDispo;
\end{verbatim}

   Et maintenant le c\oe{}ur de la meule ! Si l'entité aval est prête,
on lui dit de venir chercher une {\sc pdu} (celle-là ou une autre,
c'est l'algo qui le dira, mais on ne voit pas comment ça pourrait en
être une autre !). Sinon, on laisse tomber, \ldots

\begin{verbatim}
   } else {
      if (destDispo) {
         // Si l'aval est dispo, on lui dit de venir chercher une PDU, ce
         // qui déclanchera l'ordonnancement
         result = sched->destProcessPDU(sched->destination, rrSched_getPDU, sched);
      } else {
         // On ne fait rien si l'aval (un support a priori) n'est pas pret
         result = 0;
      }
   }
\end{verbatim}

   On oublie pas de renvoyer le résultat !

\begin{verbatim}

   printf_debug(DEBUG_SCHED, "out\n");
   return result;
}
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Utilisation}

   Ben ça c'est pas m'échant, je te laisse lire les sources !

%========================================================================
%
%========================================================================
\section{Le moteur de simulation}
\label{section:motsim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Gestion mémoire}

   L'allocation de mémoire peut s'avérer problématique, aussi la
fonction suivante a été ajoutée

\index{sim\_malloc}
\begin{verbatim}
void * sim_malloc(int l);
\end{verbatim}

   Elle présente l'avantage de vérifier le résultat de {\tt malloc}
(si les assertions sont activées) et de comptabiliser les appels afins
de détecter une fuite mémoire.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Message de débogage}

   La fonction suivante est proposée 

\index{printf\_debug}
\begin{verbatim}
   void printf_debug(int lvl, char * format, ...);
\end{verbatim}

   Elle s'utilise comme {\tt printf} avec en plus un niveau de
débogage (le premier paramètre). Un certain nombre de valeurs sont
définies dans {\tt motsim.h} parmi lesquelles

\index{DEBUG\_ALWAYS}
\begin{verbatim}
#define DEBUG_ALWAYS   0xFFFFFFFF
\end{verbatim}

   qui permet d'assurer que le message sera toujours affiché.

   Les mécanismes de débogage sont activés par la définition de la
macro {\tt DEBUG\_NDES}.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Gestion des événements}

   Elle est décrite dans {\tt event.h} et codée dans {\tt event.c}.

%........................................................................
%
%........................................................................
\subsubsection{Création d'un événement}
 
   On peut créer un événement avec la fonction suivante 

\index{event\_create}
\begin{verbatim}
struct event_t * event_create(void (*run)(void *data),
			      void * data,
			      double date);
\end{verbatim}

   Attention, l'événement ne sera exécuté que si il est placé dans la
file d'attente du simulateur. Pour cela, il faut utiliser la fonction
{\tt motSim\_addEvent}. 

   On peut créer un événement et l'insérer immédiatement dans cette
file grâce à la fonction

\index{event\_add}
\begin{verbatim}
void event_add(void (*run)(void *data),
	       void * data,
	       double date);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Création d'un événement périodique}

   Certains événements se reproduisent périodiquement, il est alors
nécessaire d'utiliser, dans le code de traitement de l'événement, la
fonction {\tt event\_add}. Une autre solution consiste à utiliser
l'une des fonctions suivantes 

\index{event\_periodicCreate}
\index{event\_periodicAdd}
\begin{verbatim}
struct event_t * event_PeriodicCreate(void (*run)(void *data),
			      void * data,
			      double date,
		              double period);
void event_periodicAdd(void (*run)(void *data),
		       void * data,
		       double date,
		       double period);

\end{verbatim}

   L'événement sera alors exécuté de façon périodique à partir de la
date fournie en paramètre.

%========================================================================
%
%========================================================================
\section{Les sondes}
\label{section:sondes}

   Les sondes sont implantées dans le modules {\tt probe}. Les sondes
permettent d'enregistrer des mesures de paramètres scalaires. Ce sont
elles qui permettront ensuite d'analyser le résultat de la simulation,
d'évaluer les performances du système, de tracer des courbes, \ldots

   Chaque échantillon d'une mesure prélevé par une sonde est daté. Il
est également possible de n'enregistrer que la date d'un événement,
sans aucune mesure associée.

   Les sondes peuvent être placées en divers points des outils de
simulation via des fonctions de la forme
\lstinline!<type>_add<point>Probe(...)!. Plusieurs sondes peuvent être
ainsi ``chaînées'' sur un même point de mesure. En revanche, la même
sonde {\bf ne peut pas} être chaînée plusieurs fois.

   Pour chacun des objets décrit dans ce fabuleux document, je
tâcherai de lister (dans une section''Les sondes'') les différents
points de mesure disponibles.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les méthodes de base}

%........................................................................
%
%........................................................................
\subsubsection{Création et destruction}

   Il existe diffférents types de sondes, et chaque type dispose d'au
moins une fonction de création spécificique. Ces différentes fonctions
seront donc listée dans la sous-section suivante.

   La destruction d'une sonde se fait grâce à la fonction 

\index{probe\_delete}
\begin{verbatim}
void probe_delete(struct probe_t * p);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{L'échantillonage}

   La méthode suivante permet d'échantilloner une valeur dans une
sonde 

\index{probe\_sample}
\begin{verbatim}
void probe_sample(struct probe_t * probe, double value);
\end{verbatim}

   Il est également possible d'échantilloner une date, sans valeur
associée, de la façon suivante 

\index{probe\_sampleEvent}
\begin{verbatim}
void probe_sampleEvent(struct probe_t * probe);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Consultation d'un échantillon}

%........................................................................
%
%........................................................................
\subsubsection{La moyenne}

%........................................................................
%
%........................................................................
\subsubsection{Les valeurs extrèmes}

%........................................................................
%
%........................................................................
\subsubsection{La mesure du débit}

   Les valeurs échantillonées pourront souvent être des tailles de
messages, émis ou reçus. Dans ce cas, il peut être intéressant
d'utiliser la fonction suivante qui fournit une mesure du ``débit
instantané''.

\index{probe\_throughput}
\begin{verbatim}
double probe_throughput(struct probe_t * p);
\end{verbatim}

   Bien sûr, le mode d'estimation de cette valeur est dépendant de la
nature de la sonde.
%........................................................................
%
%........................................................................
\subsubsection{La sauvegarde}

   Une sonde peut être dumpée dans un fichier ouvert grâce à la
fonction

{\tt void probe\_graphBarDumpFd(struct probe\_t * probe, int fd, int
format);}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les différents types}

%........................................................................
%
%........................................................................
\subsubsection{La sonde exhaustive}

   La sonde la plus simple est la sonde exhaustive. Avec une telle
sonde, tout échantillon est conservé ``définitivement''. L'avantage
d'une telle technique est que les résultats sont aussi précis qu'on
peut l'espérer, mais l'inconvénient est que cela peut s'avérer très
gourmand en ressources.

   Une sonde exhaustive est créée de la façon suivante

\index{probe\_createExhaustive}
\begin{verbatim}
struct probe_t * probe_createExhaustive();  
\end{verbatim}

   Il n'y a donc aucun paramètre.

%........................................................................
%
%........................................................................
\subsubsection{Les ``méta-sondes''}

   À chaque échantillon, certaines sondes mettent à jours des
informations que l'on peut souhaiter conserver (par exemple la moyenne
mobile) afin de tracer leur évolution dans le temps.

   Pour cela, une sonde périodique \lstinline!P! peut être placée sur
une sonde observée \lstinline!O!. La sonde \lstinline!P! permettra
ainsi d'observer une propriété de la sonde\lstinline!O! sur la base
d'un échantillonage à une fréquence caractérisant la sonde
\lstinline!P!. 

   Cette technique permet également de collecter dans une sonde unique
\lstinline!G! des échantillons prélevés dans plusieurs sondes
différentes \lstinline!S1!, \lstinline!S2!, ldots Pour cela,
\lstinline!G! sera ajoutée comme sonde sur les échantillons de
\lstinline!S1!, \lstinline!S2!, ldots 

%........................................................................
%
%........................................................................
\subsubsection{L'histogramme}

%........................................................................
%
%........................................................................
\subsubsection{La fenêtre glissante}

   Ces sondes conservent tous les échantillons sur une fenêtre
glissante dont la taille est fournie en paramêtre du constructeur :

\index{probe\_slidingWindowCreate}
\begin{verbatim}
struct probe_t * probe_slidingWindowCreate(int windowLength);
\end{verbatim}

   A tout moment, une telle sonde conserve donc au maximum les {\tt
windowLength} derniers échantillons. Toutes les valeurs observées
{\em via} une telle sonde (la moyenne, le minimum, le maximum, \ldots)
sont donc obtenues au regard de ces seuls échantillons !

   Si l'on souhaite déterminer des moyennes temporelles, on utilisera
plutôt des sondes par tranche temporelle.

%........................................................................
%
%........................................................................
\subsubsection{La sonde périodique}

   Le but d'une sonde périodique est de prélever un échantillon toutes
les $\tau$ unitées de temps. On se fonde pour cela sur l'idée que la
valeur mesurée n'est modifiée qu'au cours du traitement d'un
événement.

   La cration d'une telle sonde est réalisée par la fonction 

\index{probe\_periodicCreate}
\begin{verbatim}
struct probe_t * probe_periodicCreate(double t);
\end{verbatim}

   Le paramètre {\tt t} est évidemment la période des échantillons.

%........................................................................
%
%........................................................................
\subsubsection{La moyenne mobile}

   Une moyenne du type \lstinline!EMAProbeType! conserve à tout moment
une moyenne mobile calculée à chaque nouvel échantillon $e$ de la façon
suivante $m <- \alpha . m + (1 - \alpha).e$.

%........................................................................
%
%........................................................................
\subsubsection{La moyenne par tranches temporelles}

   Cette sonde conserve une moyenne pour chaque tranche temporelle de
durée {\tt t}, passée en paramètre du constructeur (les fenêtres
temporelles sont sautantes donc disjointes):

\begin{verbatim}
struct probe_t * probe_createTimeAverage(double t);
\end{verbatim}


%========================================================================
%
%========================================================================
\section{Les {\sc pdu}s}
\label{section:pdu}

   La {\sc pdu} est l'objet de base échangé entre les entités du
simulateur. Si on voit considère deux entités homologues qui
dialoguent, il est effectivement légitime d'utiliser ce
terme. Cependant, dans une simulation réseau faite avec {\sc ndes}, la
notion d'entité est bien plus vaste que cela si bien que ce nom est
finalement mal choisi ! N'empèche que pour le moment, je vais le
conserver !

   Les {\sc pdu}s sont définies dans le fichier {\tt pdu.h} et
implantées dans le fichier {\tt pdu.c}. Une {\sc pdu} est une
structure extrèmement légère, dotée de quelques caractéristiques de
base : un identifiant, une taille, une date de création (dans le temps
simulé), et des données privées (un pointeur).

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Création/destruction}

   On la crée avec la fonction

\index{PDU\_create}
\begin{verbatim}
struct PDU_t * PDU_create(int size, void * private);
\end{verbatim}

   Le paramètre {\tt size} est évidemment la taille en octets, et {\tt
private} peut être un pointeur vers des données privées associées à
cette {\sc pdu} (il peut être {\tt NULL}, personnellement, je m'en
fiche).

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les caractéristiques de base}

   La taille d'une {\sc pdu} est donnée par

\index{PDU\_size}
\begin{verbatim}
int PDU_size(struct PDU_t * PDU);
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les données privées}

%========================================================================
%
%========================================================================
\section{Les files de {\sc pdu}}
\label{section:file}

   C'est l'outil de base pour stocker des objets selon une stratégie
{\sc fifo}. Elles sont définies dans le fichier {\tt file\_pdu.h} et
implantées dans le fichier {\tt file\_pdu.c}. Une file ne contient que
des {\sc pdu}s mais, comme on l'a vu, les {\sc pdu}s peuvent être
utilisées pour véhiculer tout et n'importe quoi grâce à leurs données
privées. Il est donc simple de construire des files de n'importe quoi
!

   Par défaut, la taille d'une file n'est limitée quepar les capacités
du système.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Création}

   Une file est créée de la façon suivante 

\index{filePDU\_create}
\begin{verbatim}
struct filePDU_t * filePDU_create(void * destination,
			    processPDU_t destProcessPDU);
\end{verbatim}

   Le paramètre \lstinline!destination! est un pointeur sur l'objet
vers lequel sont transmis les objets présents dans la file. Dés qu'un
objet est inséré dans la file, si la destination est disponible, il
lui est envoyé au travers de la fonction \lstinline!destProcessPDU!
passée en paramètre.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Insertion}

   On insère dans une file avec une fonction assez classique :

\index{filePDU\_insert}
\begin{verbatim}
void filePDU_insert(struct filePDU_t * file,
		    struct PDU_t * PDU);
\end{verbatim}

   Mais on dispose également de la fonction d'entrée-sortie homogène
avec le reste du simulateur :

\index{filePDU\_processPDU}
\begin{verbatim}
int filePDU_processPDU(void * file,
		       getPDU_t getPDU,
		       void * source);
\end{verbatim}

   Elle permet d'utiliser la file comme n'importe quelle autre entité
dans un simulateur (voir par exemple le premier tutoriel).

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Extraction}

   L'extraction d'une {\sc pdu} d'une file est réalisé par :

\index{filePDU\_extract}
\begin{verbatim}
struct PDU_t * filePDU_extract(struct filePDU_t * file);
\end{verbatim}

   dont la valeur de retour peut être {\tt NULL} en cas de file vide.

   La aussi, une fonction spécifique à la simulation est fournie :

\index{filePDU\_getPDU}
\begin{verbatim}
struct PDU_t * filePDU_getPDU(void * file);
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Gestion de la taille}

   Deux fonctions permettent de consulter la taille de la file, la
première donne la taille en nombre de {\sc pdu}s

\index{filePDU\_length}
\begin{verbatim}
int filePDU_length(struct filePDU_t * file);
\end{verbatim}

   la seconde donne la somme cumulée des tailles des {\sc pdu}s
présentes :

\index{filePDU\_size}
\begin{verbatim}
int filePDU_size(struct filePDU_t * file);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Taille maximale}

   Il est possible de limiter la taile d'une file. La borne supérieure
peut être exprimée en nombre de {\sc pdu}s présentes ou en taille
cumulée :

\index{filePDU\_setMaxSize}
\index{filePDU\_setMaxLength}
\begin{verbatim}
void filePDU_setMaxSize(struct filePDU_t * file, unsigned long maxSize);
void filePDU_setMaxLength(struct filePDU_t * file, unsigned long maxLength);
\end{verbatim}

   Une valeur nulle signifie l'absence de limite (c'est la valeur par
défaut). Les deux paramètres peuvent être utilisés simultanéments
(c'est alors le plus contraignant qui bloque). Leur valeur peut être
consultée grâce à l'une des fonctions suivantes :

\index{filePDU\_getMaxSize}
\index{filePDU\_getMaxLength}
\begin{verbatim}
unsigned long filePDU_getMaxSize(struct filePDU_t * file);
unsigned long filePDU_getMaxLength(struct filePDU_t * file);
\end{verbatim}

%........................................................................
%
%........................................................................
\subsubsection{Et en cas de débordement ?}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les sondes}

   Les files sont dotées des points de mesure suivants

\begin{description}
   \item[{\tt InsertSize}] pour mesurer la taille des paquets insérés
     dans la file. A chaque insertion d'une {\sc pdu}, la taille de
     cette dernière est échantillonée avec la date d'insertion.
   \item[{\tt ExtractSize}] pour mesurer la taille des paquets extraits
     de la file. A chaque extraction d'une {\sc pdu}, la taille de
     cette dernière est échantillonée avec la date d'extraction.
   \item[{\tt DropSize}]
   \item[{\tt Sejourn}]
\end{description}

   On peut ajouter une sonde sur chacun de ces points de mesure avec
une fonction de la forme

\begin{verbatim}
   void filePDU_add<measure>Probe(struct filePDU_t * file,
                                  struct probe_t   * probe);
\end{verbatim}

%========================================================================
%
%========================================================================
\section{Les générateurs aléatoires}
\label{section:rand-gen}

   Dans un simulateur, la génération de nombres aléatoires est un
élément important. Dans {\sc ndes}, on prend ces choses-là très au
sérieux. Du coup, la gestion des nombres aléatoires est une horreur
sans nom ! J'avoue avoir moi-même du mal à comprendre. La bonne
nouvelle c'est que du coup le résultat est vraiment \ldots{}
aléatoire.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Caractéristiques d'un générateur aléatoire}

   Un générateur aléatoire est caractérisé par trois composantes
fondamentales 

\begin{description}
   \item[Le type des données générées] peut être réel, entier,
     discret, \ldots
   \item[La loi] peut être uniforme, exponentielle, \ldots
   \item[La source] permet de déterminer la qualité de l'aléa, et par
     exemple de le rendre déterministe (afin d'obtenir la même
     séquence sur plusieurs simulation).
\end{description}

   Attention, ces trois composantes sont éventuellement constitutées
d'un jeu de paramètres.

   Le principe général de génération d'une valeur est le suivant.

\begin{itemize}
   \item Un nombre aléatoire est fourni par la source. Ce sera un
     entier entre deux valeurs extrèmes, par exemple, en fonction de
     la nature de la source.
   \item Une transformation est appliquée afin de respecter la
     densité de probabilité de la loi.
   \item Une seconde transformation est appliquée pour obtenir une
     valeur du type voulu.
\end{itemize}

   Bref, tout est fait pour laisser sa place au hasard \ldots


%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Utilisation}

   Le schéma général d'utilisation est simple : on crée un générateur,
on l'initialise avec le type de données voulu, on lui associe une
distribution, éventuellement on peut changer la source d'aléa sur
laquelle il se fonde, puis on peut lui extirper des valeurs aléatoires
et enfin on le détruit sans un mot de remerciement.

   Observons en détail les fonctions utiles à ce programme alléchant.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Création et destruction}

   Il existe au moins une fonction de création pour chaque type de
données géré (il manquerait plus que ça !). Mais il existe également
parfois des fonctions permettant de spécifier en même temps la
distribution à utiliser. Voyons ça type par type.

%.......................................................................
%
%.......................................................................
\subsubsection{Les entiers non signés}

   La fonction de création de base est 

\index{randomGenerator\_createUInt}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUInt();
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Les entiers non signés entre {\tt min} et {\tt max} inclus}

   Ça c'est sympa pour jouer aux dés. On les crée avec 

\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntRange(unsigned int min,
						      unsigned int max);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Une liste d'entiers non signés}

   Pratique pour tirer au hasard des tailles de paquets !

\index{randomGenerator\_createUIntDiscrete}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntDiscrete(int nbValues,
							      unsigned int * values);
\end{verbatim}

   Le premier paramètre donne le nombre de valeurs, et le second est
un tableau qui contient (au moins) ces valeurs. Son contenu sera
recopié, donc si tu veux le détruire/modifier ensuite, vis ta vie !

   Comme on se doute bien que dans ce genre de situations on va
vouloir associer une probabilité à chaque valeur, on peut utiliser la
version suivante :

\index{randomGenerator\_createUIntDiscreteProba}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntDiscreteProba(
				int nbValues,
				unsigned int * values,
				double * proba);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Des réels double précision}

   On crée un tel générateur avec la fonction suivante

\index{randomGenerator\_createDouble}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDouble();
\end{verbatim}

   On peut également en créer un fondé sur une distribution
exponentielle de paramètre {\tt lambda} :

\index{randomGenerator\_createDoubleExp}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDoubleExp(double lambda);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Des réels double précision entre {\tt min} et {\tt max}}

\begin{verbatim}
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{Une liste de réels double précision}

   Pour générer des nombres aléatoires choisis dans une liste fournie
en paramètre :

\index{randomGenerator\_createDoubleDiscrete}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDoubleDiscrete(
                                     int nbValues,
                                     double * values);
\end{verbatim}

   ou, en fournissant directement les probabilités :

\index{randomGenerator\_createDoubleDiscreteProba}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDoubleDiscreteProba(
                                     int nbValues,
                                     double * values,
                                     double * proba);
\end{verbatim}

   Les paramètres sont analogues à la version fondée sur des entiers
non signés, bref, voir ci-dessus.

%.......................................................................
%
%.......................................................................
\subsubsection{Destruction}

   On détruit un générateur grâce à la fonction

\index{randomGenerator\_delete}
\begin{verbatim}
void randomGenerator_delete(struct randomGenerator_t * rg);
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Choix de la loi}

   Avant de pouvoir être utilisé, un générateur aléatoire doit être
caractérisé par la loi qui le gouverne. Il existe des fonctions
spécifiques à cet objectif. Certaines fonctions de création font appel
à l'une ou l'autre de ces fonctions, mais pas toute ! Attention donc à
s'assurer qu'une distribution est associée à un générateur avant de
l'utiliser.

%.......................................................................
%
%.......................................................................
\subsubsection{Loi uniforme}

   On spécifie une loi uniforme grâce à la fonction suivante

\index{randomGenerator\_setDistributionUniform}
\begin{verbatim}
void randomGenerator_setDistributionUniform(struct randomGenerator_t * rg);
\end{verbatim}

   Attention, le type des données peut être un intervalle borné
``continu'' ou un ensemble discret, mais s'il s'agit d'un intervalle
non borné, le résultat est \ldots {} aléatoire.

%.......................................................................
%
%.......................................................................
\subsubsection{Loi  explicite}

   Je ne sais pas trop comment l'appeler celle-là ! L'idée est qu'on
fournit explicitement toutes les probabilités. Elle est spécifiée par
la fonction suivante :

\index{randomGenerator\_setDistributionDiscrete}
\begin{verbatim}
void randomGenerator_setDistributionDiscrete(struct randomGenerator_t * rg,
					     int nb,
                                             double * proba);
\end{verbatim}

   Attention, elle ne s'applique de toute évidence qu'à des données
discrètes !

   Les probabilités sont copiées par la fonctions donc le pointeur
{\tt proba} peut être libéré ensuite.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Choix de la source}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Génération d'une valeur}

\index{randomGenerator\_getNextUInt}
\index{randomGenerator\_getNextDouble}

   Une nouvelle valeur est obtenue à chaque appel d'une des fonctions
suivantes (à choisir en fonction du type attendu)

\begin{verbatim}
unsigned int randomGenerator_getNextUInt(struct randomGenerator_t * rg);
double randomGenerator_getNextDouble(struct randomGenerator_t * rg);
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Les sondes}

%========================================================================
%
%========================================================================
\section{Les générateurs de dates}
\label{section:date-gen}

%========================================================================
%
%========================================================================
\section{Le serveur générique}
\label{section:srv_gen}

   Le serveur générique permet de modéliser à moindre frais un
serveur. Il est définit dans le fichier {\tt srv-gen.h}.

%========================================================================
%
%========================================================================
\section{Le puits}
\label{section:puits}

%========================================================================
%
%========================================================================
\section{L'affichage par GnuPlot}
\label{section:gnuplot}

%========================================================================
%
%========================================================================
\section{Notion de simulation et de campagne}

   Une simulation est une instance unique d'exécution d'une séquence
d'événements suite à l'initialisation du modèle. Une campagne est une
suite de simulations sur un même modèle avec une ré-initialisation des
variables entre deus simulations.

   Les sondes liées à la simulation sont ré-initialisées à la fin de
la simulation. Des sondes peuvent être liées à la campagne ; elles ne
seront réinitialisées qu'à la fin de cette dernière et peuvent
permettre ainsi à établir des valeurs inter-simulation, par exemple
des intervalles de confiance.


%========================================================================
%
%========================================================================
\section{Des exemples}

   Le répertoire {\tt examples} des sources de {\sc ndes} comprend un
certain nombre d'exemples. Certains de ces exemples servent de
tutoriels et ont donc été décrits précédemment. D'autres sont
présentés ici.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Utilisation des sondes}

\subsubsection{Mesurer un débit}

   Le programme d'exemple {\tt debits.c} montre plusieurs méthodes de
calcul d'un débit.

   Considérons le cas simple d'une source, dont nous voulons mesurer
le débit de sortie. Pour cela, nous allons insérer une sonde sur la
taille des paquets transmis grâce à la méthode {\tt
  PDUSource\_setPDUGenerationSizeProbe}.

   Le type de sonde dépendra de la mesure souhaitée.

%.......................................................................
%
%.......................................................................
\paragraph{Débit moyen}

   Supposons que nous voulons simplement connaître le débit moyen sur
toute la transmission, alors une sonde mesurant la moyenne sera parfaitement
suffisante :

%.......................................................................
%
%.......................................................................
\paragraph{Débit ``instantanté''}

%========================================================================
%
%========================================================================
\section{La librairie}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Une source de {\sc pdu}}

   Un objet de type {\tt PDUSource\_t} permet de produire des {\sc
pdu}s selon différentes lois.  Ce type est défini dans le fichier {\tt
     pdu-source.h}. 

   Une source de {\sc pdu}s est essentiellement caractérisée par deux
jeux de parmètres

\begin{itemize}
   \item l'un définissant la loi qui régit les dates de créations
     des {\sc pdu}s ;
   \item l'autre définissant la loi qui régit les tailles de {\sc
     pdu}.
\end{itemize}

%.......................................................................
%
%.......................................................................
\subsubsection{Création d'une source}

   Une source est créée par la fonction 

\index{PDUSource\_create}
\begin{verbatim}
struct PDUSource_t * PDUSource_create(struct dateGenerator_t * dateGen,
				      void * destination,
				      processPDU_t destProcessPDU);
\end{verbatim}

   Par défaut, la taille des {\sc pdu}s produites est constante égale
à 0.

   Une fonction particulière permet la création d'une source
``déterministe''. Une telle source est initialisée avec une séquence
de couples {\tt \{date, taille\}} qui définit explicitement la liste
des dates et tailles de {\sc pdu}s à produire. Un tel outil ne peut
être utilisé que pour un nombre limité de {\sc pdu}s, mais il est très
pratique à des fins de démonstration ou débogage.

   La fonction d'initialisation est la suivante

\index{PDUSource\_createDeterministic}
\begin{verbatim}
struct PDUSource_t * PDUSource_createDeterministic(struct dateSize * sequence,
						   void * destination,
						   processPDU_t destProcessPDU);
\end{verbatim}

   Le type {\tt struct dateSize} est défini ainsi

\index{struct dateSize}
\begin{verbatim}
struct dateSize {
   double date;
   unsigned int size;
};
\end{verbatim}

   La séquence passée en paramètre à {\tt
     PDUSource\_createDeterministic} doit être ordonnée
   chronologiquement et terminée par un couple {\tt \{0.0, 0\}}.
%.......................................................................
%
%.......................................................................
\subsubsection{Activation d'une source}

%.......................................................................
%
%.......................................................................
\subsubsection{Choix de la loi des dates}

%.......................................................................
%
%.......................................................................
\subsubsection{Choix de la loi des tailles}

%.......................................................................
%
%.......................................................................
\subsubsection{Activation d'une source}

%.......................................................................
%
%.......................................................................
\subsubsection{Les sondes}


%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Un lien unidirectionnel}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Un lien {\sc dvb-s2}}

   Le module {\tt dvb-s2-ll} permet de simuler une liaison de type
DVB-S2.

\subsubsection{Création}

Une telle entité sera créée grâce à la fonction suivante

\index{DVBS2ll\_create}
\begin{verbatim}
struct DVBS2ll_t * DVBS2ll_create(void * destination,
				  processPDU_t destProcessPDU,
				  unsigned long  symbolPerSecond,
				  unsigned int FECFrameBitLength);
\end{verbatim}

   Les caractéristiques principales du canal sont passées en
   paramètres.
Pour simplifier le
paramètrage, les macros suivantes sont fournies

\index{FEC\_FRAME\_BITSIZE\_LARGE}
\begin{verbatim}
#define FEC_FRAME_BITSIZE_LARGE 64800
\end{verbatim}

\subsubsection{Ajout/modification d'un MODCOD}

   À un canal DVB-S2 doit être associé un certain nombre de MODCODs
disponibles. Cela se fait par la fonction suivante

\index{DVBS2ll\_addModcod}
\begin{verbatim}
int DVBS2ll_addModcod(struct DVBS2ll_t * dvbs2ll,
		      unsigned int bbframeBitLength,
		      unsigned int bitsPerSymbol);
\end{verbatim}

   La valeur retourné est l'indice du MODCOD. Pour simplifier le
paramètrage, les macros suivantes sont fournies

\index{C14SIZE}
\index{C13SIZE}
\index{C25SIZE}
\index{C12SIZE}
\index{C35SIZE}
\index{C23SIZE}
\index{C34SIZE}
\index{C45SIZE}
\index{C56SIZE}
\index{C89SIZE}
\index{C910SIZE}
\index{MQPSK}
\index{M8PSK}
\index{M16APSK}
\index{M32APSK}
\begin{verbatim}
#define  C14SIZE  16008
#define  C13SIZE  21408
#define  C25SIZE  25728
#define  C12SIZE  32208
#define  C35SIZE  38688
#define  C23SIZE  43040
#define  C34SIZE  48408
#define  C45SIZE  51648
#define  C56SIZE  53840
#define  C89SIZE  57472
#define  C910SIZE 58192

#define   MQPSK    2
#define   M8PSK    3
#define   M16APSK  4
#define   M32APSK  5
\end{verbatim}

   Si l'on souhaite modifier le MODCOD n, par exemple pour refléter un
chagenement de conditions de réception, on pourra utiliser la fonction

\index{DVBS2ll\_setModcod}
\begin{verbatim}
void DVBS2ll_setModcod(struct DVBS2ll_t * dvbs2ll,
                       int n,
		       unsigned int bbframeBitLength,
		       unsigned int bitsPerSymbol);
\end{verbatim}

\subsubsection{Exemple}

   À titre d'exemple, voici le code permettant de créer un lien DVB-S2
(menant par exemple vers un puits) de 10Msymboles/sec avec 4 MODCODs :

\begin{verbatim}
struct DVBS2ll_t * dvbS2;

...

dvbS2 = DVBS2ll_create(sink,
                       (processPDU_t)PDUSink_processPDU,
                       FEC_FRAME_BITSIZE_LARGE,
                       10000000);
DVBS2ll_addModcod(dvbS2, C13SIZE, MQPSK);
DVBS2ll_addModcod(dvbS2, C25SIZE, M8PSK);
DVBS2ll_addModcod(dvbS2, C34SIZE, M16APSK);
DVBS2ll_addModcod(dvbS2, C56SIZE, M16APSK);
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Un ordonnanceur {\sc acm}}

   Les fichiers {\tt schedACM.h} et {\tt schedACM.c} définissent et
implantent un cadre général et des fonctions communes permettant de
construire des algorithmes d'ordonnancement pour des liens implantant
des techniques de type {\sc acm} ({\em Adaptive Coding and
  Modulation}).

   L'objectif de cette structure est de faire des choses aussi
génériques que possible qui puissent être adaptées à différents
contexte. Ce n'est pas encore complètement le cas et ces fichiers
restent relativement dépendants de DVB-S2.

%.......................................................................
%
%.......................................................................
\subsubsection{Ajout d'une file}

%.......................................................................
%
%.......................................................................
\subsubsection{Principe général}

   Le principe général est le suivant.

\begin{itemize}
   \item L'ordonnanceur va chercher une ``solution'' par le biais d'une
   fonction {\tt schedule}.
   \item Une trame va être construite en fonction de cette solution
     par la fonction {\tt buildBBFRAME}.
   \item Cette trame sera transmise au travers de la fonction {\tt
     getPDU}.
\end{itemize}

   Cette structure est assez riche car une ``solution'' peut être
extrèmement complexe. Nous envisageons en effet ici le cas le plus
général dans lequel il est éventuellement possible de transmettre
plusieurs paquets dans une même trame.

   De ce fait, une ``solution'' sera décrite par une structure
permettant cette souplesse.

%.......................................................................
%
%.......................................................................
\subsubsection{Les fonctions spécifiques à un ordonnanceur}

   Chaque type d'ordonnanceur {\sc acm} pourra implanter un certain
nombre de fonctions spécifiques. Elles seront enregistrées dans une
structure du type suivant 

\index{struct schedACM\_func\_t}
\begin{verbatim}
struct schedACM_func_t {
   struct PDU_t * (*getPDU)(void * private);
   int  (*processPDU)(void * private,
	               getPDU_t getPDU, void * source);

   struct PDU_t * (* buildBBFRAME)(void * private);

   void (*schedule)(void * private);
};
\end{verbatim}

   Les trois premières sont optionnelles, car une fonction par défaut
est définie qui devrait convenir dans la plupart des cas. C'est la
dernière qui implante l'algorithme lui-même, elle est donc nécessaire.

\paragraph{La fonction {\tt getPDU}}  est la fonction qui sera invoquée pour
demander à l'ordonnanceur de ``produire'' une {\sc pdu} (en
ordonnançant des paquets). Si elle n'est pas définie, la fonction
\index{schedACM\_getPDUGeneric}{\tt schedACM\_getPDUGeneric} sera
utilisée par défaut. Cette fonction se contente de faire appel à la
fonction {\tt buildBBFRAME}.

\paragraph{La fonction {\tt buildBBFRAME}} a pour rôle de construire
une trame avec les paquets choisis par l'ordonnanceur. Elle renvoie
donc un pointeur vers la {\sc pdu} ains créée. En l'absence d'une
telle fonction définie, c'est la fonction
\index{schedACM\_buildBBFRAMEGeneric} {\tt
  schedACM\_buildBBFRAMEGeneric} qui sera invoquée.

   Nous décrirons cette fonction plus loin.

%.......................................................................
%
%.......................................................................
\subsubsection{Définition des solutions}

   Nous l'avons dit, une solution trouvée par l'ordonnanceur peut être
composés de plusieurs paquets, provenant éventuellement de
plusieurs files.

   La structure permettant de modéliser cela est la suivante

\index{t\_remplissage}
\begin{verbatim}
typedef struct {
   int       modcod;         //!< Le numero de MODCOD choisi
   int    ** nbrePaquets;    //!< Nombre de paquets de chaque file à transmettre
   int       volumeTotal;    //!< Le nombre total d'octets à transmettre

   /* Les champs suivants sont à la dispo de l'ordonnanceur. Il
      faudrait surement faire plus propre, avec un  pointeur sur prive
      ou une union, ... */
   double    interet;
   int       nbChoix;        // Nombre de choix menant à cet interet
   int       casTraite;      // Pour éviter de retraiter un cas
} t_remplissage ;
\end{verbatim}


%.......................................................................
%
%.......................................................................
\subsubsection{La fonction {\tt schedACM\_buildBBFRAMEGeneric}}
\index{schedACM\_buildBBFRAMEGeneric|(}

   Cette fonction s'occupe de consulter la solution fournie par
l'ordonnanceur, de construire la trame correspondante et d'extraire
les paquets à transmettre des files d'entrée.

\index{schedACM\_buildBBFRAMEGeneric|)}
%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Un ordonnanceur {\sc acm} par knapsack}

   Les fichiers {\tt sched\_ks.h} et {\tt sched\_ks.c} définissent et
implante un ordonnancement sur un lien ACM, typiquement DVB-S2 en se
fondant une recherche par l'algorithme du sac à dos.

%.......................................................................
%
%.......................................................................
\subsubsection{Création}

   Une instance de l'ordonanceur est créé par 

\index{sched\_kse\_create}
\begin{verbatim}
struct schedACM_t * sched_kse_create(struct DVBS2ll_t * dvbs2ll,
				     int nbQoS,
				     int declOK,
				     int exhaustif);
\end{verbatim}

   Les paramètres ont la signification suivante

\begin{description}
   \item[{\tt dvbs2ll}] est un pointeur vers le lien  DVB-S2 au
     travers duquel les paquets seront transmis.
   \item[{\tt nbQoS}] est le nombre de files de qualité de service à
     considérer par MODCOD.
   \item[{\tt declOK}] est un booléen validant l'utilisation du déclassement.
   \item[{\tt exhaustif}] permet de choisir la version exhaustive de
     l'algorithme. 
\end{description}

   Le pointeur fourni en retour est de type {\tt struct schedACM\_t *
   }. Voir ce type ci dessus pour plus de précisions.

%========================================================================
%
%========================================================================
\section{Index des fonctions}

\printindex

\end{document}
