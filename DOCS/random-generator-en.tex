%========================================================================
%
%========================================================================
\section{The random generators}
\label{section:random-generator}

  In a simulator, the generation of random numbers is an important part. 
In {\sc ndes}, we take this very serious. The random number generator 
management is a nameless horror! I admit I had problems understanding it too. 
The good knews is that the result is really \ldots{} random.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{The characteristics of a random generator}

 A random generator is characterised by three important components:

\begin{description}
   \item[The type of generated data] can be real, integer,
     discrete, \ldots
   \item[The law] can be uniform, exponential, \ldots
   \item[The source] permits to determine the quality of the randomness, and 
by example to render it deterministic (to obtain the same sequence with other 
simulation).
\end{description}

  Be careful, these three components eventualy use some parameters.
  
    The general principle for generating a variable is described below.

\begin{itemize}
   \item A random number is provided by the source. It will be a
      integer between two extreme values​​, for example, depending on
      the nature of the source.
   \item A transformation is applied to meet the probability density 
      of the law.
   \item A second transformation is applied to obtain a
      value of the desired type.
\end{itemize}

   Shortly, everything is done to make the generation random \ldots


%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Using the generators}

  The general schema for using the generator is simple: we create a generator,
we initialise with the desired values, we associate with it a probability 
distribution, eventualy we can change the source of randomness on which it is based,
then we can extract the random values and at the end we destroy the generator.

   Observe in detail relevant functions of this exciting program.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{The creation and the distruction}
   
   There is at least a function of creation for each type of
managed data (it fails more than that!). But sometimes, there are also
functions to specify the distribution to use at the same time. 
See this type per type.

%.......................................................................
%
%.......................................................................
\subsubsection{The unsigned integers}

   The function for creating the base is 

\index{randomGenerator\_createUInt}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUInt();
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{The unsigned integeres between {\tt min} and {\tt max}}

   It is fun to play dice. This can be created with

\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntRange(unsigned int min,
						      unsigned int max);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{A list of unsigned integers}

   Practice to randomize packet sizes!

\index{randomGenerator\_createUIntDiscrete}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntDiscrete(int nbValues,
							      unsigned int * values);
\end{verbatim}

   The first parameter gives the number of values, and the second is 
a table which contains (at least) these values. Its contents will be
copied, so if you want to destroy / modify then, you're free to do it!
   As there is little doubt that in such situations we will
want to assign a probability to each value, you can use the
following version:

\index{randomGenerator\_createUIntDiscreteProba}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createUIntDiscreteProba(
				int nbValues,
				unsigned int * values,
				double * proba);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{The real numbers in double precision}

   We create a generator with the following function

\index{randomGenerator\_createDouble}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDouble();
\end{verbatim}

   We may also create one generator based on an exponential distribution
parameter {\tt lambda} :

\index{randomGenerator\_createDoubleExp}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDoubleExp(double lambda);
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{The real numbers in double precision between {\tt min} and {\tt max}}

\begin{verbatim}
\end{verbatim}

%.......................................................................
%
%.......................................................................
\subsubsection{A list of real numbers in double precision}

   For generating random numbers from a list with provided
parameters:

\index{randomGenerator\_createDoubleDiscrete}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDoubleDiscrete(
                                     int nbValues,
                                     double * values);
\end{verbatim}

   or, providing the probabilities directly:

\index{randomGenerator\_createDoubleDiscreteProba}
\begin{verbatim}
struct randomGenerator_t * randomGenerator_createDoubleDiscreteProba(
                                     int nbValues,
                                     double * values,
                                     double * proba);
\end{verbatim}

   The parameters are similar to the release based on unsigned short 
int, according on what we see above.

%.......................................................................
%
%.......................................................................
\subsubsection{The distruction}

   We destroy the generator with the function

\index{randomGenerator\_delete}
\begin{verbatim}
void randomGenerator_delete(struct randomGenerator_t * rg);
\end{verbatim}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Choosing the law}

   Before it can be used, a random generator need to be characterised
by a law who governs it. There are specific functions for this purpose. 
Some function of creation call either of these functions, but not all! 
So be careful to ensure that a distribution is associated with a generator 
before using it.

%.......................................................................
%
%.......................................................................
\subsubsection{Uniform law}

   We specify a uniform law through the following function

\index{randomGenerator\_setDistributionUniform}
\begin{verbatim}
void randomGenerator_setDistributionUniform(struct randomGenerator_t * rg);
\end{verbatim}
   
   Be careful, the type of data can be a "continuous" bounded interval
or a discrete set, but if it is an unbounded interval, the result is
\ldots {} random.

%.......................................................................
%
%.......................................................................
\subsubsection{Explicit law}
   
   I do not know how to call that! The idea is that it explicitly provides 
all the probabilities. It is specified by the following function:
   
\index{randomGenerator\_setDistributionDiscrete}
\begin{verbatim}
void randomGenerator_setDistributionDiscrete(struct randomGenerator_t * rg,
					     int nb,
                                             double * proba);
\end{verbatim}
   
   Attention, it obviously only applies to discrete data!

   The probabilities are copied by the functions so the pointer
{\tt proba} can be released.

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Choosing the source}

%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{Generating a value}

\index{randomGenerator\_getNextUInt}
\index{randomGenerator\_getNextDouble}

   A new value is obtained at each call of the following functions 
(chosen according to the expected type)

\begin{verbatim}
unsigned int randomGenerator_getNextUInt(struct randomGenerator_t * rg);
double randomGenerator_getNextDouble(struct randomGenerator_t * rg);
\end{verbatim}

\subsection{Generating a random number with Weibull distribution}

\index{randomGenerator\_setDistributionWeibull}
\index{randomGenerator\_WeibullInit}
\index{randomGenerator\_WeibullGetNext}

Weibull distribution is characterized by two parameters, $\alpha$ and $\beta$.
To generate a random number based on Weibull distribution, we need a random value, which we get from rg->aleaGetNext. Then, we apply the inverse CDF of Weibull distribution:

  $$Weibull\_CDF^{-1}(x,\alpha,\beta)=\beta*(-\ln(1-x))^{1/\alpha}$$

\begin{verbatim}
void randomGenerator_setDistributionWeibull(struct randomGenerator_t * rg, double alpha, double beta)
{
   rg->distribution = rGDistWeibull;
   randomGenerator_WeibullInit(rg, alpha, beta);
}
\end{verbatim}


\begin{verbatim}
void randomGenerator_WeibullInit(struct randomGenerator_t * rg, double alpha, double beta)
{
      assert(rg->distribution == rGDistWeibull);   
      rg->distParam.min = 0.0;
      rg->distParam.max = DBL_MAX;
  
      rg->distParam.d.alpha = alpha;
      rg->distParam.d.beta  = beta; 
      rg->distGetNext = randomGenerator_WeibullGetNext;
}
\end{verbatim}

\begin{verbatim}
double randomGenerator_WeibullGetNext(struct randomGenerator_t * rg)
{
      double alea, result;
      alea = rg->aleaGetNext(rg);

        result = rg->distParam.d.beta *  pow(-log(1-alea), 
                                       1/rg->distParam.d.alpha);
     return result;
}
\end{verbatim}

\subsection{Generating a random number with Lognormal distribution}

\index{randomGenerator\_setDistributionLognormal}
\index{randomGenerator\_LognormalInit}
\index{randomGenerator\_LognormalGetNext}

Lognormal distribution is characterized by two parameters, $\alpha$ and $\beta$.
To generate a random number based on Lognormal distribution, we need a random value, which we get from rg->aleaGetNext. Then, we apply the inverse CDF of Lognormal distribution:

   $$ Lognormal\_CDF^{-1}(x,\alpha,\beta) = e^{\alpha + \beta * sqrt{2} * errorfunction(2*x-1)^{-1}} $$

\begin{verbatim}
void randomGenerator_setDistributionLognormal(struct randomGenerator_t * rg, double alpha, double beta)
{
   rg->distribution = rGDistLognormal;
   randomGenerator_LognormalInit(rg, alpha, beta);
} 
\end{verbatim}

\begin{verbatim}
void randomGenerator_LognormalInit(struct randomGenerator_t *rg, double alpha, double beta)
{
      assert(rg->distribution == rGDistLognormal);   
      rg->distParam.min = 0.0;
      rg->distParam.max = DBL_MAX;
  
   rg->distParam.d.alpha = alpha;
   rg->distParam.d.beta  = beta; 
   rg->distGetNext = randomGenerator_LognormalGetNext;

}
\end{verbatim}

\begin{verbatim}
double randomGenerator_LognormalGetNext(struct randomGenerator_t *rg)
{  
      double alea;
      double result ;
   
   alea = rg->aleaGetNext(rg);

   result = exp (   rg->distParam.d.alpha + 
                    rg->distParam.d.beta * sqrt(2) * pow(erf(2*alea - 1), -1) 
                );

   return result;

}  
\end{verbatim}

\subsection{Generating a random number with Gamma distribution}

\index{randomGenerator\_setDistributionGamma}
\index{randomGenerator\_GammaInit}
\index{randomGenerator\_GammaGetNext}

Gamma distribution is characterized by two parameters, $\alpha$ and $\beta$.
To generate a random number based on Gamma distribution, we need a random value, which we get from rg->aleaGetNext. Then, we apply the inverse CDF of Gamma distribution:
  
  $$ Gamma\_CDF^{-1}(x, \alpha, \beta) = (\Gamma(\alpha, \beta/x))/\Gamma(alpha) $$

   Where $$\Gamma(\alpha, x) = \int_x^\infty \! \beta^{\alpha-1}*e^{-\beta}\, \mathrm{d}\beta $$

   and $$\Gamma(\alpha, x) + \gamma(\alpha, x) = \Gamma(\alpha) $$

   Such that $$ \Gamma(\alpha, x) = \Gamma(\alpha) - \gamma(\alpha, x) $$

 We can aproximate $\gamma(\alpha, x)$ (the lower incomplete gamma function) in the following way:
\begin{verbatim}
double incgamma(double x, double alpha)   // aproximation of lower incomplete gamma function
{
 double sum = 0;  // aprox of integral
 double term = 1.0 / alpha;
 int n=1; 
    while(term!=0)
    {
         sum  += term;
         term *= x/(alpha+n);
         n++;
    }
  return pow(x, alpha-1) * exp(-x) * sum;
}
\end{verbatim}

The functions used to initialize and set the distribution:
\begin{verbatim}
void randomGenerator_setDistributionGamma(struct randomGenerator_t * rg, double alpha, double beta)
{
   rg->distribution = rGDistGamma;
   randomGenerator_GammaInit(rg, alpha, beta);
} 
\end{verbatim}


\begin{verbatim}
void randomGenerator_GammaInit(struct randomGenerator_t *rg, double alpha, double beta)
{
      assert(rg->distribution == rGDistGamma);   
      rg->distParam.min = 0.0;
      rg->distParam.max = DBL_MAX;
  
   rg->distParam.d.alpha = alpha;
   rg->distParam.d.beta  = beta; 
   rg->distGetNext = randomGenerator_GammaGetNext;
}
\end{verbatim}

\begin{verbatim}
double randomGenerator_GammaGetNext(struct randomGenerator_t * rg)
{
   double alea, result;
   alea = rg->aleaGetNext(rg);

   result = ( tgamma(rg->distParam.d.alpha) - incgamma(rg->distParam.d.alpha, rg->distParam.d.beta/alea ) ) / tgamma(rg->distParam.d.alpha); 
  
  
   return result;
}
\end{verbatim}

\section{Composed random generator}

   I defined the possibility of a random generator to have parameters maximum three random generators differently distributed. We have many possibilities: Pareto, Gamma, Lognormal, Weibull. These random generators "create" random numbers that can be used in any expression we want for the source random generator.
The idea came from the proposed method of http model wrote in "Source Traffic Modeling of Wireless Applications".

A requested webpage is composed from:
\begin{itemize}
\item{a main object} - its size is Lognormal distributed
\item{a variable number of inline objects} - its size is Lognormal distributed and the number of objects is Gamma distributed
\end{itemize}


\begin{verbatim}
//!< Parameters describing the distribution 
   struct {
      double min, max; // Extreme values
      union {
         double lambda; //!< Exponential distribution
         double alpha, beta;
        
         struct randomGenerator_t * szmain;
         struct randomGenerator_t * szin;
         struct randomGenerator_t * nin;

         struct {       //!< Discrete distribution
            int nbProba;
            double * proba;
         } discrete;
         struct {           //!< ITS distribution
            int nbParam;    //!< Quantile function number of parameters 
            double p1, p2;  //!< Parameters values
	    union {
               double(*q0par)(double x);
               double(*q1par)(double x, double p1);
               double(*q2par)(double x, double p1, double p2);
            } q;    //!< Quantile function
         } its;
      } d;
   } distParam; 
\end{verbatim}

 The main principle is the same as the other random generators.
We need an Init function, a setDistribution function and a GetNext method.
As an example, I implemented the example from the document with the webpage:

\begin{verbatim}
void randomGenerator_setDistributionComposed(struct randomGenerator_t * rg, double main_alpha, double main_beta, double inline_alpha, double inline_beta, double nalpha, double nbeta)
{
 
  rg->distribution = rGDistComposed;
  

  randomGenerator_ComposedInit(rg, main_alpha, main_beta, inline_alpha, inline_beta, nalpha, nbeta);

}
\end{verbatim}


\begin{verbatim}
double randomGenerator_ComposedGetNext(struct randomGenerator_t *rg)
{
    double mainsize, inlinesize;
    int inlinenumber;
    double result;
    
    mainsize = randomGenerator_LognormalGetNext(rg->distParam.d.szmain);
    inlinesize = randomGenerator_LognormalGetNext(rg->distParam.d.szin);
    inlinenumber = (int) randomGenerator_GammaGetNext(rg->distParam.d.nin);
    
    result = mainsize + inlinenumber * inlinesize;    

    return result;
}
\end{verbatim}


\begin{verbatim}
void randomGenerator_ComposedInit(struct randomGenerator_t *rg, 
                                  double main_alpha, double main_beta,
                                  double inline_alpha, double inline_beta,
                                  double nalpha, double nbeta)
{
   assert(rg->distribution == rGDistComposed);
   
   rg->distParam.d.szmain = randomGenerator_createDouble();
   randomGenerator_setDistributionLognormal(rg->distParam.d.szmain, main_alpha, main_beta);

   rg->distParam.d.szin = randomGenerator_createDouble();
   randomGenerator_setDistributionLognormal(rg->distParam.d.szin, inline_alpha, inline_beta);

   rg->distParam.d.nin = randomGenerator_createDouble();
   randomGenerator_setDistributionGamma(rg->distParam.d.nin, nalpha, nbeta);
  
  rg->distGetNext = randomGenerator_ComposedGetNext;  
    
}
\end{verbatim}


%------------------------------------------------------------------------
%
%------------------------------------------------------------------------
\subsection{The sondes}

